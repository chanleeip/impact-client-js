/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/": {
    /** Can be used by client to check that the API is of a version it supports. The APIs version is semantic. */
    get: operations["getAPIMetaData"];
  };
  "/login": {
    /** When the login succeeds, the response includes a cookie containing an access token which is used for further identification with the REST API. The login is managed by a third party authorization service. To authenticate against the REST API, an API key may be included in the optional request body. The API key can be created <a class="visible-link" href="/admin/keys">in the API key manager</a>. */
    post: operations["login"];
  };
  "/workspaces": {
    /** The workspace ID in the returned object serve as unique IDs that can be used in other API calls to perform operations for a specific workspace. */
    get: operations["getWorkspaces"];
    /** If creating a workspace with a name already existing, this call will have no effect. Importing a workspace with a name already existing will give it a new name. */
    post: operations["createWorkspace"];
    /** Used when not a specific workspace should be deleted but rather all workspaces with some attribute. */
    delete: operations["deleteWorkspaces"];
  };
  "/workspaces/{workspace}": {
    get: operations["getWorkspaceId"];
    /** Can be called periodically on a cloned workspace a client is working against. This will inform the system that this workspace is not inactive and may not be deleted. */
    put: operations["increaseClonedWorkspaceTimestamp"];
    delete: operations["deleteWorkspace"];
    parameters: {
      path: {
        /** ID of the workspace */
        workspace: string;
      };
    };
  };
  "/workspaces/{workspace}/exports": {
    /** The compressed workspace may be downloaded, after successful completion of a call to this endpoint, by calling GET /workspaces/{workspace}/exports/{exportId}. */
    post: operations["prepareExportWorkspace"];
    parameters: {
      path: {
        /** ID of the workspace */
        workspace: string;
      };
    };
  };
  "/workspaces/{workspace}/exports/{exportId}": {
    /** The workspace needs to be compressed by calling POST /workspaces/{workspace}/exports, before calling this API endpoint. */
    get: operations["exportWorkspace"];
    /** This API end point can be be called after a compressed workspace has been downloaded. */
    delete: operations["deleteExportedWorkspace"];
    parameters: {
      path: {
        /** ID of the workspace */
        workspace: string;
        /** ID of the compressed workspace to download */
        exportId: string;
      };
    };
  };
  "/workspaces/{workspace}/clone": {
    /** A created clone of a workspace is a temporary resource. It can be used executing some workload based on resources of a workspace without mutating or adding anything to it. */
    post: operations["cloneWorkspace"];
    parameters: {
      path: {
        /** ID of the workspace */
        workspace: string;
      };
    };
  };
  "/workspaces/{workspace}/dependencies": {
    /** Get workspace dependencies. */
    get: operations["getWorkspaceDependencies"];
    parameters: {
      path: {
        /** ID of the workspace */
        workspace: string;
      };
    };
  };
  "/workspaces/{workspace}/projects": {
    /** Get workspace projects. */
    get: operations["getWorkspaceProjects"];
    parameters: {
      path: {
        /** ID of the workspace */
        workspace: string;
      };
    };
  };
  "/libraries": {
    /** top-level libraries are available for all workspaces. It does not return any meta data for libraries stored in specific workspaces. */
    get: operations["getTopLevelLibraries"];
  };
  "/workspaces/{workspace}/libraries": {
    get: operations["getLibraries"];
    post: operations["importLibrary"];
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
      };
    };
  };
  "/workspaces/{workspace}/libraries/{library}": {
    /** The accept head is used to specify if meta data or the library itself is returned. With the default accept header '*\/*' the libraries meta data will be returned. If changed to application/zip the library will be downloaded as a zip-file if the library is structured. For an unstructured library the acceptance header text/plain can be used to download it as a mo-file. */
    get: operations["exportLibrary"];
    delete: operations["deleteLibrary"];
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
        /** The library identifier, '{name} {version}' or '{name}' if version is missing */
        library: string;
      };
    };
  };
  "/workspaces/{workspace}/libraries/{library}/models": {
    post: operations["importFMU"];
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
        /** The library identifier, '{name} {version}' or '{name}' if version is missing */
        library: string;
      };
    };
  };
  "/workspaces/{workspace}/custom-functions/{custom-function}": {
    /** Gets the meta-data for a custom function describing which parameters the custom function accepts (read more about the response for details). Note that the system comes with default custom functions thar are always available. Furthermore, you can read more about custom functions and setting up the system with your own in the Modelon Impact help center. */
    get: operations["getCustomFunction"];
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
        /** Name of the custom function */
        "custom-function": string;
      };
    };
  };
  "/workspaces/{workspace}/custom-functions/{custom-function}/options": {
    /** Gets the (aggregated) options for a custom function. This includes: Workspace specific options, options configured as defaults for the application, default options specified in the custom function. For options specified on multiple levels, the value is taken primarily from the workspace specific options, secondarily from the application default options and in third hand from the custom function default options. */
    get: operations["getExecutionOptions"];
    /** The values for the options are saved for a specific custom function and workspace. */
    put: operations["putExecutionOptions"];
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
        /** Name of the custom function */
        "custom-function": string;
      };
    };
  };
  "/workspaces/{workspace}/custom-functions/{custom-function}/default-options": {
    /** Gets the application level default options for a custom function. This includes: Options configured as defaults for the application and default options specified in the custom function. For options specified on both levels, the value is taken from the application default options. */
    get: operations["getDefaultExecutionOptions"];
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
        /** Name of the custom function */
        "custom-function": string;
      };
    };
  };
  "/workspaces/{workspace}/custom-functions": {
    /** Which custom functions that exists are useful when setting up an experiment using POST /workspaces/{workspace}/experiments. The name of a custom function is used for the field 'analysis_function' which specifies that it should be used for the experiment. The meta-data also describes which parameters each custom function accepts (read more about the response for details). Note that the system comes with default custom functions thar are always available. Furthermore, you can read more about custom functions and setting up the system with your own in the Modelon Impact help center. */
    get: operations["getCustomFunctions"];
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
      };
    };
  };
  "/workspaces/{workspace}/options/units/conversions": {
    get: operations["getUnitConversionFactors"];
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
      };
    };
  };
  "/workspaces/{workspace}/model-executables": {
    get: operations["getAllModelExecutableInfo"];
    /** The name of the model to be compiled is specified by the field 'class_name'. The remaining fields in the input are options for the compilation process. For a reference of what options can be used in the field 'compiler_options' and 'runtime_option' see the OCT User's Guide, which can be found in the Modelon Impact help center. If the FMU should be executed in Impact (rather than exported) it is recommended that 'fmi_target' is 'me', 'fmi_version' is '2.0' and 'platform' is 'auto'. If this end-point is called with the query parameter 'getCached' set to true, then a previously compiled model executable is returned, if such an FMU exists. To get a cached model executable (FMU) there must exists a successfully compiled model executable that was compiled with the same inputs as in the current call. Furthermore, if the Modelica model for which the FMU compilation is requested has been changed in a structural way, or at least one of its dependent models have changed, then a cached FMU will not be returned. Setting non-structural parameters and making graphical changes to the Modelica model will not break the cache for its compiled FMU. */
    post: operations["modelExecutableSetup"];
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
      };
    };
  };
  "/workspaces/{workspace}/model-executables/supported-platforms": {
    /** Can be used to find which values are supported for the field 'platform' when calling the POST method on '/workspaces/{workspace}/model-executables' */
    get: operations["getFmuPlatforms"];
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
      };
    };
  };
  "/workspaces/{workspace}/model-executables/{fmuId}": {
    get: operations["getModelExecutableInfo"];
    delete: operations["deleteModelExecutable"];
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
        /** The FMU ID */
        fmuId: string;
      };
    };
  };
  "/workspaces/{workspace}/model-executables/{fmuId}/compilation": {
    get: operations["getCompilationStatus"];
    /** First call POST /workspaces/{workspace}/model-executables to setup what should be compiled. */
    post: operations["modelExecutableCompile"];
    delete: operations["cancelCompilation"];
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
        /** Reference ID to the model to be compiled */
        fmuId: string;
      };
    };
  };
  "/workspaces/{workspace}/model-executables/{fmuId}/compilation/log": {
    get: operations["downloadCompilationLog"];
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
        /** Reference ID to the compiled model */
        fmuId: string;
      };
    };
  };
  "/workspaces/{workspace}/model-executables/{fmuId}/binary": {
    get: operations["downloadCompiledFMU"];
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
        /** Reference ID to the compiled model */
        fmuId: string;
      };
    };
  };
  "/workspaces/{workspace}/model-executables/{fmuId}/steady-state-metadata": {
    post: operations["getFmuMeta"];
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
        /** Reference ID to the compiled model */
        fmuId: string;
      };
    };
  };
  "/workspaces/{workspace}/model-executables/{fmuId}/settable-parameters": {
    /** Can be used to find what parameters are feasible to have as modifiers in an experiment. */
    get: operations["getFmuParameters"];
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
        /** Reference ID to the compiled model */
        fmuId: string;
      };
    };
  };
  "/workspaces/{workspace}/model-executables/{fmuId}/string-parameters-and-values": {
    /** Gets a list of parameters whose values are strings and one list with respective value in order. Can be used when requiring string parameters that don't come with the result. */
    get: operations["getFmuStringParametersAndValues"];
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
        /** Reference ID to the compiled model */
        fmuId: string;
      };
    };
  };
  "/workspaces/{workspace}/experiments": {
    get: operations["getAllExperimentInfo"];
    /**
     * The required inputs for setting up a multi-execution experiment is either 'id' in 'base/model/fmu' OR 'className' in 'base/model/modelica', along with 'type' in 'base/analysis'. These can be obtained from POST /workspaces/{workspace}/model-executables and GET /workspaces/{workspace}/custom-functions respectively. The FMU 'id' specifies what FMU the experiment is based on, and analysis 'type' specifies what analysis custom function is used for each case of the experiment. Furthermore, experiments support multi-execution, i.e., batch computations where each case executes a custom function. Multi-execution experiments can be set up in two ways.
     *
     * The first way to setup multi-execution experiments is to specify 'operators' for 'modifiers' which are applied to the base experiment. An example experiment for this could contain the 'modifiers': {'variables': {'x': 'range(1, 2, 3)'}}, which would result in a multi-execution experiment with three cases: x=1, x=1.5, and x=2. Note that if multiple 'operators' are used for different variables, the experiment will be expand to cases with all combinations of parametrizations, i.e., full factorial is used to expand the experiment. Here is a full example using the range operator to create cases:
     *
     * <pre>
     * {
     *   "experiment": {
     *     "version": 2,
     *     "base": {
     *       "model": {
     *         "fmu": {
     *           "id": "workspace_pid_controller_20090615_134530_as86g32"
     *         }
     *       },
     *       "modifiers": {
     *         "variables": {
     *           "inertia1.J": "range(1, 2, 10)",
     *         }
     *       },
     *       "analysis": {
     *         "type": "dynamic",
     *         "parameters": {
     *           "start_time": 0,
     *           "final_time": 1
     *         }
     *       }
     *     }
     *   }
     * }
     * </pre>
     *
     * The other way of defining an experiment is to specify 'extensions' to the 'base' definition, where each 'extension' is combined with 'base' to create a case. For example, an experiment with the 'extensions': [{'modifiers': {'variables': {'x': 1}}}, {'modifiers': {'variables': {'x': 1.5}}}, {'modifiers': {'variables': {'x': 2}}}], would result in the same multi-execution as above (if no modifiers are defined in 'base'). This way of creating cases gives more freedom to the client to set up a multi-execution experiment, since cases are defined by parameter configurations, as opposed to operators (like the range operator). This approach also allows different options and custom function parameters to be used for the different cases. These two methods of setting up a multi-execution cannot be combined. So, if any extensions are given, it is not allowed to include any 'operators' anywhere in the experiment. It is however allowed to provide parameter values (with no operators) in 'base' in combination with defining cases with 'extensions'. In this case, parameters set in 'extensions' overrides those set in 'base'.
     *
     * The following example shows how 'extensions' are used to set options and parameters for separate cases and thereby overriding the values in the 'base' definition. The 'base' definition in the example have 'analysis': {'type': 'dynamic', 'parameters': {'start_time': 2, 'final_time': 3}}, and 'modifiers': {'variables': {'x': 1, 'y': 3}}}. If used with the 'extensions':
     *
     * [{'analysis': {'parameters': {'final_time': 4}}}, 'modifiers': {'variables': {'y': 5}}}, {'analysis': {'parameters': {'start_time': 1}}}, 'modifiers': {'variables': {'x': 2}}}],
     *
     * we will get two cases. The first case will use 2 for 'start_time' from the 'base' and 4 for 'final_time' as it is overridden by the 'extension', in the same way it will use 'x'=1 and 'y'=5 as modifiers. The second case overrides 'start_time' and 'x' and will result in 'start_time'=1, 'final_time'=3, 'x'=2, and 'y'=3.
     *
     * The old (version 1) experiment format can still be used but will be removed in a future version.
     */
    post: operations["setupExperiment"];
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
      };
    };
  };
  "/workspaces/{workspace}/experiments/{experimentId}": {
    get: operations["getExperimentInfo"];
    /** Can be used to set a human readable identifier for an experiment. */
    put: operations["setLabel"];
    delete: operations["removeExperiment"];
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
        /** The ID of the experiment */
        experimentId: string;
      };
    };
  };
  "/workspaces/{workspace}/experiments/{experimentId}/execution": {
    get: operations["getExecutionStatus"];
    /** First call POST /workspaces/{workspace}/experiments to setup what should be executed. */
    post: operations["execute"];
    delete: operations["cancelExecution"];
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
        /** The ID of the experiment */
        experimentId: string;
      };
    };
  };
  "/workspaces/{workspace}/experiments/{experimentId}/cases": {
    get: operations["getAllCaseInfo"];
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
        /** The ID of the experiment */
        experimentId: string;
      };
    };
  };
  "/workspaces/{workspace}/experiments/{experimentId}/cases/{caseId}": {
    get: operations["getCaseInfo"];
    /** This end-point can be used to update a case input. This can be used to modify the case and then execute the case again as part of an experiment and get different results for the case. Only fields under 'input' and 'meta' can be updated. Also, the fields 'fmu_id', 'analysis_function', 'structural_parametrization' and 'fmu_base_parametrization' cannot be updated. After a case is updated the 'consistent' field will be set to 'false' to signify that case results might not match the case input. Executing the case as part of an experiment will set 'consistent' to 'true'. The recomended way to update the case is to first use the corresponding GET end-point, modify some data, then call PUT (this end-point) with that data. */
    put: operations["putCaseInfo"];
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
        /** The ID of the experiment */
        experimentId: string;
        /** The ID of the case */
        caseId: string;
      };
    };
  };
  "/workspaces/{workspace}/experiments/{experimentId}/cases/{caseId}/log": {
    get: operations["getCaseLog"];
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
        /** The ID of the simulation */
        experimentId: string;
        /** The ID of the case */
        caseId: string;
      };
    };
  };
  "/workspaces/{workspace}/experiments/{experimentId}/cases/{caseId}/result": {
    get: operations["getCaseResults"];
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
        /** The ID of the experiment */
        experimentId: string;
        /** The ID of the case */
        caseId: string;
      };
    };
  };
  "/workspaces/{workspace}/experiments/{experimentId}/cases/{caseId}/trajectories": {
    /** This end-point can be used to fetch trajectories from cases that have finished executing. The trajectories are then typically used to visualize the result by plotting variables as a function of time or as X-Y plots. Which variables exists in a result can be obtained from the end-point GET /workspaces/{workspace}/experiments/{experimentId}/variables. Most experiments contain the independent variable 'time', with the custom function 'dynamic' being a notable example of this. So, to plot 'x' against 'time' for an experiment with a single case and the custom function 'dynamic', call this end-point with the input {'variable_names': ['x', 'time']} and plot 'item' 1 against 'item' 2 from the response. See the response description for more details on the structure of the response. The old (version 1) trajectory format can still be used but will be removed in a future version. */
    post: operations["getCaseTrajectories"];
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
        /** The ID of the experiment */
        experimentId: string;
        /** The ID of the case */
        caseId: string;
      };
    };
  };
  "/workspaces/{workspace}/experiments/{experimentId}/cases/{caseId}/custom-artifacts/{artifactId}": {
    get: operations["getCustomArtifact"];
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
        /** The ID of the experiment */
        experimentId: string;
        /** The ID of the case */
        caseId: string;
        /** The ID of the artifact */
        artifactId: string;
      };
    };
  };
  "/workspaces/{workspace}/experiments/{experimentId}/variables": {
    get: operations["getVariables"];
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
        /** The ID of the experiment */
        experimentId: string;
      };
    };
  };
  "/workspaces/{workspace}/experiments/{experimentId}/trajectories": {
    /** This end-point can be used to fetch trajectories from experiments that has finished executing. The trajectories are then typically used to visualize the result by plotting variables as a function of time or as X-Y plots. Which variables exists in a result can be obtained from the end-point GET /workspaces/{workspace}/experiments/{experimentId}/variables. Most experiments contain the independent variable 'time', with the custom function 'dynamic' being a notable example of this. So, to plot 'x' against 'time' for an experiment with a single case and the custom function 'dynamic', call this end-point with the input {'variable_names': ['x', 'time']} and plot 'item' 1 against 'item' 2 under 'case_1' in the response. See the response description for more details on the structure of the response. The old (version 1) trajectory format can still be used but will be removed in a future version. */
    post: operations["getTrajectories"];
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
        /** The ID of the experiment */
        experimentId: string;
      };
    };
  };
  "/workspace-exports": {
    /** The compressed workspace will be prepared. After a successful completion of a call to this endpoint, call GET /workspace-exports/{exportId} to check status. */
    post: operations["prepareExportWorkspaceAsync"];
    parameters: {};
  };
  "/workspace-exports/{exportId}": {
    /** The workspace needs to be setup for export by calling POST /workspace-exports, before calling this API endpoint. */
    get: operations["exportWorkspaceAsync"];
    /** This API end point can be be called after a compressed workspace has been downloaded. */
    delete: operations["deleteExportedWorkspaceAsync"];
    parameters: {
      path: {
        /** ID of the compressed workspace to check status on */
        exportId: string;
      };
    };
  };
  "/workspace-imports": {
    /** Will initiate import of an existing workspace. After a successful completion of a call to this endpoint, call GET /workspace-imports/{importId} to check status. */
    post: operations["importWorkspace"];
  };
  "/workspace-imports/{importId}": {
    /** The workspace needs to be setup for import by calling POST /workspace-imports, before calling this API endpoint. */
    get: operations["importWorkspaceStatus"];
    /** This API end point can be be called after a workspace has been imported. */
    delete: operations["deleteWorkspaceImport"];
    parameters: {
      path: {
        /** ID of the workspace import to check status on */
        importId: string;
      };
    };
  };
  "/exports/{exportId}": {
    /** This route is used for downloading exported files. Other end-points will reference here with a download URI */
    get: operations["exportFile"];
    parameters: {
      path: {
        /** ID of the compressed workspace to download */
        exportId: string;
      };
    };
  };
  "/uploads/results": {
    post: operations["uploadMAT"];
  };
  "/uploads/results/{uploadId}": {
    /** Get the current status of upload for a given uploadId */
    get: operations["getUploadStatus"];
    parameters: {
      path: {
        /** Id for result storage */
        uploadId: string;
      };
    };
  };
  "/external-result/{uploadId}": {
    /** Gets the meta-data for a result file */
    get: operations["getUploadedResultEntity"];
    delete: operations["deleteUploadedResultEntity"];
    parameters: {
      path: {
        /** Id for result storage */
        uploadId: string;
      };
    };
  };
  "/users/me": {
    /** Returns the ID of the current user, which is used to create API keys, and the external IDs connected to it. */
    get: operations["getCurrentUser"];
    parameters: {};
  };
  "/users/{userId}/keys": {
    /** Get information on the API keys belonging to the user by the given ID. The information includes the key ID and the creation time but not the secret key itself. */
    get: operations["getAPIkeys"];
    /** Creates a new API key belonging to the user with the given ID. The response contains a new API key which is the only time this key can be retrieved. They key must be safely stored by the recepient, as there is no way to retrieve it at a later point. A user may only have one API key at a time, so if it is lost or compromised, it must be deleted before a new one can be created. The API key can be used with the /login endpoint to log in. Each key has an ID to identify it when deleting it. */
    post: operations["postAPIkey"];
    parameters: {
      path: {
        /** ID of the user */
        userId: string;
      };
    };
  };
  "/users/{userId}/keys/{keyId}": {
    /** Deletes an API key with the given ID, belonging to a specified user. */
    delete: operations["deleteAPIKey"];
  };
  "/keys/validation": {
    /** Validates an API key. */
    post: operations["validateAPIKey"];
  };
}

export interface components {
  schemas: {
    Error: {
      error?: {
        /**
         * @description Error message describing what went wrong
         * @example There was an error X because of Y
         */
        message?: string;
        /**
         * @description Error code for identifying specific errors
         * @example 12012
         */
        code?: number;
      };
    };
    /** @description Workspace meta-data */
    Workspace: {
      /**
       * @description Unique workspace identifier.
       * @example my_workspace
       */
      id: string;
      /** @description True, if the workspace is a clone. */
      is_clone: boolean;
      /** @description If field exists, workspace is a read only dashboard workspace */
      dashboard?: {
        /**
         * @description The model to view in the dashboard workspace
         * @example Modelica.Blocks.Examples.PID_Controller
         */
        model: string;
      };
    };
    Case: {
      /**
       * @description Case ID.
       * @example case_1
       */
      id?: string;
      run_info: {
        /**
         * @description Status of the case run, can be 'successful', 'failed', 'not_started' or 'cancelled'
         * @example successful
         */
        status?: string;
        /**
         * @description At which stage the case failed if 'status' is 'failed', can be 'simulation' or 'compilation'. If 'status' is not 'failed' it will be null
         * @example simulation
         */
        failed_at?: string;
        /**
         * @description The unix time the case started running
         * @example 1549552749
         */
        datetime_started?: number;
        /**
         * @description The unix time the case finshed running
         * @example 1549552338
         */
        datetime_finished?: number;
        /**
         * @description Describes if the case 'input' is consistent with the latest case run. Will be false if the case has been updated and not executed since then
         * @example false
         */
        consistent?: boolean;
      };
      meta: {
        /**
         * @description Case label
         * @example Cruise operating point
         */
        label?: unknown;
      };
      input: {
        /**
         * @description Reference ID to the compiled model used running the case
         * @example workspace_pid_controller_20090615_134530_as86g32
         */
        fmu_id?: string;
        /** @description The analysis object */
        analysis: {
          /**
           * @description the name of the function to run
           * @example dynamic
           */
          analysis_function: string;
          /**
           * @description parameters to the function
           * @example {
           *   "start_time": 0,
           *   "final_time": 1
           * }
           */
          parameters?: { [key: string]: unknown };
          /** @description Key-value pairs of simulation options */
          simulation_options?: { [key: string]: number | string | boolean };
          /** @description Key-value pairs of solver options */
          solver_options?: { [key: string]: number | string | boolean };
          /**
           * @description The simulation log level
           * @enum {string}
           */
          simulation_log_level?:
            | "NOTHING"
            | "FATAL"
            | "ERROR"
            | "WARNING"
            | "INFO"
            | "VERBOSE"
            | "DEBUG"
            | "ALL";
        };
        /** @description Parameterization of the case, a list of key value pairs where key is variable name and value is the value to use  for that variable */
        parametrization?: { [key: string]: unknown };
        /** @description Structural parameterization of the case, a list of key value pairs where key is variable name and value is the value to use for that variable. These are values that cannot be applied to the FMU/Model after compilation */
        structural_parametrization?: { [key: string]: unknown };
        /** @description This is some base parametrization that must be applied to the FMU for it to be valid running this case. It often comes as a result from of caching to reuse the FMU */
        fmu_base_parametrization?: { [key: string]: unknown };
        /** @description Initialize the simulation using values from a previous simulation by giving the corresponding experiment ID and case ID. Details on how the initialization is done depend on the custom function. */
        initialize_from_case?: {
          /** @description Experiment ID to initialize from */
          experimentId: string;
          /** @description Case ID to initialize from */
          caseId: string;
        };
        /** @description Initialize the simulation using an uploaded result file. Details on how the initialization is done depends upon the custom function. */
        initialize_from_external_result?: {
          /**
           * @description The ID of the result import
           * @example 2f036b9fab6f45c788cc466da327cc78workspace
           */
          uploadId: string;
        };
      };
    };
    CaseExecutionOptions: {
      options: {
        /**
         * @description Key-value pairs of compilation options
         * @example {
         *   "generate_html_diagnostics": true,
         *   "halt_on_warning": true
         * }
         */
        compiler?: { [key: string]: number | string | boolean };
        /**
         * @description Key-value pairs of run-time options
         * @example {
         *   "use_Brent_in_1d": false
         * }
         */
        runtime?: { [key: string]: number | string | boolean };
        /**
         * @description Key-value pairs of simulation options
         * @example {
         *   "ncp": 2000
         * }
         */
        simulation?: { [key: string]: number | string | boolean };
        /**
         * @description Key-value pairs of solver options
         * @example {
         *   "rtol": 0.0001
         * }
         */
        solver?: { [key: string]: number | string | boolean };
      };
    };
    /**
     * @description Specifies expansion algorithm and its parameters.
     * @example {
     *   "algorithm": "LatinHyperCube",
     *   "parameters": {
     *     "samples": 5,
     *     "seed": 1
     *   }
     * }
     */
    Expansion:
      | components["schemas"]["LatinHyperCube"]
      | components["schemas"]["Sobol"]
      | components["schemas"]["FullFactorial"]
      | components["schemas"]["Saltelli"];
    FullFactorial: {
      /**
       * @description Full factorial expansion algorithm
       * @enum {string}
       */
      algorithm?: "FULLFACTORIAL";
    };
    LatinHyperCube: {
      /**
       * @description Latin hypercube sampling expansion algorithm
       * @enum {string}
       */
      algorithm: "LATINHYPERCUBE";
      /** @description Latin hypercube expansion algorithm parameters */
      parameters: {
        /** @description The number of samples. Must be an integer greater than 1. */
        samples: number;
        /** @description The seed for random number generation. Default: None */
        seed?: number;
      };
    };
    Sobol: {
      /**
       * @description Latin hypercube sampling expansion algorithm
       * @enum {string}
       */
      algorithm: "SOBOL";
      /** @description Latin hypercube expansion algorithm parameters */
      parameters: {
        /** @description The number of samples. Must be an integer greater than 1. */
        samples: number;
      };
    };
    Saltelli: {
      /**
       * @description Saltelli expansion algorithm
       * @enum {string}
       */
      algorithm: "SALTELLI";
      /** @description Latin hypercube expansion algorithm parameters */
      parameters: {
        /** @description The number of samples per (non-singular) modifier in the following sensitivity analysis. Must be a positive integer. It corresponds to the accuracy/resolution of the following sensisivity analysis and depends on the number of non-singular modifiers D. The number of cases in the resulting experiment expansion will be - N*(2*D + 2) if secondOrderAnalysis == true and N*(D + 2) if secondOrderAnalysis == false, where N is samplesPerModifier and D is the number of non-singular modifiers. */
        samplesPerModifier: number;
        /** @description Set to true if the resulting samples are to be used for second order sensitivity analysis, otherwise set to false. */
        secondOrderAnalysis: boolean;
      };
    };
    /** @description A compilation error with file and class location info */
    ErrorWithFileAndClassLocation: {
      /**
       * @description The compilation error
       * @example The binding expression of the variable x does not match the declared type of the variable
       */
      msg?: string;
      /** @enum {string} */
      locationType?: "FileAndClassLocation";
      location?: {
        class?: {
          /** @example 2 */
          beginColumn?: number;
          /** @example 2 */
          endColumn?: number;
          /** @example 2 */
          beginLine?: number;
          /** @example 2 */
          endLine?: number;
          /**
           * @description Class name
           * @example Workspace.Example
           */
          qualifiedName?: string;
        };
        file?: components["schemas"]["FileLocation"];
      };
    };
    /** @description A compilation error with file location info */
    ErrorWithFileLocation: {
      /**
       * @description The compilation error
       * @example Compilation error
       */
      msg?: string;
      /** @enum {string} */
      locationType?: "FileLocation";
      location?: components["schemas"]["FileLocation"];
    };
    /** @description A compilation error without location info */
    ErrorWithNoLocation: {
      /**
       * @description The compilation error
       * @example Compilation error
       */
      msg?: string;
      /** @enum {string} */
      locationType?: "NoLocation";
    };
    /** @description A compilation error with path location info */
    ErrorWithPathLocation: {
      /**
       * @description The compilation error
       * @example Compilation error
       */
      msg?: string;
      /** @enum {string} */
      locationType?: "PathLocation";
      location?: {
        /**
         * @description Path to a file used in compilation
         * @example /impact/libraries/BrokenLib/BrokenFile.moc
         */
        path?: string;
      };
    };
    ModelExecutableRunInfoV2: {
      /** @example workspace_pid_controller_20090615_134530_as86g32 */
      id?: string;
      /** @description The input for how the compilation was done */
      input?: {
        /**
         * @description Model class name
         * @example Workspace.PID_Controller
         */
        class_name?: string;
        /**
         * @description Compiler options settings
         * @example {
         *   "generate_html_diagnostics": true
         * }
         */
        compiler_options?: { [key: string]: unknown };
        /**
         * @description Runtime options settings
         * @example {
         *   "log_level": 4
         * }
         */
        runtime_options?: { [key: string]: unknown };
        /**
         * @description Compiler log level
         * @example info
         */
        compiler_log_level?: string;
        /**
         * @description Flavour of the FMU
         * @example me
         */
        fmi_target?: string;
        /**
         * @description Version of FMI for the FMU
         * @example 2.0
         */
        fmi_version?: string;
        /**
         * @description Platform for FMU binary
         * @example win64
         */
        platform?: string;
        /**
         * @description An unique identifier representing some state of all models and libraries used when compiling
         * @example 2b3a4-adf3
         */
        model_snapshot?: string;
        /**
         * @description List of libraries not used when compiling
         * @example [VDL, ML]
         */
        disabled_libs?: string[];
        /**
         * @description Representing an aggregated version of all tooling used when compiling, will now always be 0.0.1
         * @example 0.0.1
         */
        toolchain_version?: string;
      };
      /** @description The run info of the compilation */
      run_info?: {
        /**
         * @description String that is 'cancelled', 'failed' or 'successful' depending on if the compilation finished successfully
         * @example failed
         */
        status?: string;
        /**
         * @description The unix time the compilation was started
         * @example 1549552749
         */
        datetime_started?: number;
        /** @description An array containing the compilation errors in case status is 'failed' */
        errors?: (
          | components["schemas"]["ErrorWithFileAndClassLocation"]
          | components["schemas"]["ErrorWithFileLocation"]
          | components["schemas"]["ErrorWithNoLocation"]
          | components["schemas"]["ErrorWithPathLocation"]
        )[];
        /**
         * @description The unix time the compilation was finished
         * @example 1549552338
         */
        datetime_finished?: number;
      };
    };
    ModelExecutableRunInfoV1: {
      /** @example workspace_pid_controller_20090615_134530_as86g32 */
      id?: string;
      /** @description The input for how the compilation was done */
      input?: {
        /**
         * @description Model class name
         * @example Workspace.PID_Controller
         */
        class_name?: string;
        /**
         * @description Compiler options settings
         * @example {
         *   "generate_html_diagnostics": true
         * }
         */
        compiler_options?: { [key: string]: unknown };
        /**
         * @description Runtime options settings
         * @example {
         *   "log_level": 4
         * }
         */
        runtime_options?: { [key: string]: unknown };
        /**
         * @description Compiler log level
         * @example info
         */
        compiler_log_level?: string;
        /**
         * @description Flavour of the FMU
         * @example me
         */
        fmi_target?: string;
        /**
         * @description Version of FMI for the FMU
         * @example 2.0
         */
        fmi_version?: string;
        /**
         * @description Platform for FMU binary
         * @example win64
         */
        platform?: string;
        /**
         * @description An unique identifier representing some state of all models and libraries used when compiling
         * @example 2b3a4-adf3
         */
        model_snapshot?: string;
        /**
         * @description List of libraries not used when compiling
         * @example [VDL, ML]
         */
        disabled_libs?: string[];
        /**
         * @description Representing an aggregated version of all tooling used when compiling, will now always be 0.0.1
         * @example 0.0.1
         */
        toolchain_version?: string;
      };
      /** @description The run info of the compilation */
      run_info?: {
        /**
         * @description String that is 'cancelled', 'failed' or 'successful' depending on if the compilation finished successfully
         * @example failed
         */
        status?: string;
        /**
         * @description The unix time the compilation was started
         * @example 1549552749
         */
        datetime_started?: number;
        /**
         * @description An array containing the compilation errors in case status is 'failed'
         * @example [
         *   "Could not match 'variable1' with any equation",
         *   "Nominal of 'variable2' is 0"
         * ]
         */
        errors?: string[];
        /**
         * @description The unix time the compilation was finished
         * @example 1549552338
         */
        datetime_finished?: number;
      };
    };
    FileLocation: {
      /** @example 2 */
      beginColumn?: number;
      /** @example 2 */
      endColumn?: number;
      /** @example 2 */
      beginLine?: number;
      /** @example 2 */
      endLine?: number;
      /**
       * @description Modelica code snippet from error location. Entire lines of location, no consideration to columns is done.
       * @example   Real x = "asdf";
       */
      context?: string;
      /**
       * @description Filename
       * @example /impact/workspaces/example_workspace/model_libraries/editable/Workspace/Example.mo
       */
      file?: string;
    };
    /** @description The analysis object */
    Analysis: {
      /**
       * @description The name of the custom function that will be executed
       * @example dynamic
       */
      type: string;
      /**
       * @description Parameters to the custom function
       * @example {
       *   "start_time": 0,
       *   "final_time": 1
       * }
       */
      parameters?: { [key: string]: number | string | boolean };
      /** @description Key-value pairs of simulation options */
      simulationOptions?: { [key: string]: number | string | boolean };
      /** @description Key-value pairs of solver options */
      solverOptions?: { [key: string]: number | string | boolean };
      /**
       * @description The simulation log level.
       * @default WARNING
       * @enum {string}
       */
      simulationLogLevel:
        | "NOTHING"
        | "FATAL"
        | "ERROR"
        | "WARNING"
        | "INFO"
        | "VERBOSE"
        | "DEBUG"
        | "ALL";
    };
    /**
     * @example {
     *   "variables": {
     *     "integrator.k": 1,
     *     "inertia1.J": "uniform(1,5)",
     *     "inertia2.J": 2
     *   },
     *   "initializeFrom": ""
     * }
     */
    Modifiers: {
      /** @description Specifies parameter values and ranges. The range operator allows a range of values to be described: e.g. range(0,1,5) describes 5 evenly spaced values between 0 and 1: [0,0.25,0.5,0.75,1]. If multiple range operators are specified, a full factorial expansion is used to determine all different parameterizations for the experiment */
      variables?: { [key: string]: number | string | boolean };
      /** @description Initialize the simulation using values from a previous simulation by giving the corresponding experiment ID. The experiment used must be for a simulation with a single case, otherwise 'initializeFromCase' must be used. Details on how the initialization is done depend on the custom function. */
      initializeFrom?: string;
      /** @description Same as 'initializeFrom' but also the case ID to initialize from must be specified. Can be reference a case from an experiment with multiple cases */
      initializeFromCase?: {
        /** @description Experiment ID to initialize from */
        experimentId: string;
        /** @description Case ID to initialize from */
        caseId: string;
      };
      /**
       * @description The ID of the result import
       * @example 2f036b9fab6f45c788cc466da327cc78workspace
       */
      initializeFromExternalResult?: string;
    };
    /** @description List of extensions to define cases. Each 'extension' defined will be merged with 'base' to create a case. When merging 'base' with an 'extension', the 'extension' will override the corresponding definitions in 'base'. It is not possible to use any operators (like the range operator) when using extensions. */
    Extensions: {
      /**
       * @example {
       *   "variables": {
       *     "inertia2.J": 5
       *   }
       * }
       */
      modifiers?: {
        /** @description Specifies parameter values. */
        variables?: { [key: string]: number | string | boolean };
        /** @description Initialize the simulation using values from a previous simulation by giving the corresponding experiment ID. The experiment used must be for a simulation with a single case, otherwise 'initializeFromCase' must be used. Details on how the initialization is done depend on the custom function. */
        initializeFrom?: string;
        /** @description Same as 'initializeFrom' but also the case ID to initialize from must be specified. Can be reference a case from an experiment with multiple cases */
        initializeFromCase?: {
          /** @description Experiment ID to initialize from */
          experimentId: string;
          /** @description Case ID to initialize from */
          caseId: string;
        };
      };
      /** @description An array of case data. Only the first index in the case data array will be used for extensions currently. */
      caseData?: {
        /** @description Specifies case label. */
        label?: unknown;
      }[];
      /** @description The analysis object */
      analysis?: {
        /**
         * @description Parameters to the custom function
         * @example {
         *   "start_time": 0,
         *   "final_time": 1
         * }
         */
        parameters?: { [key: string]: number | string | boolean };
        /** @description Key-value pairs of simulation options */
        simulationOptions?: { [key: string]: number | string | boolean };
        /** @description Key-value pairs of solver options */
        solverOptions?: { [key: string]: number | string | boolean };
        /**
         * @description The simulation log level
         * @default WARNING
         * @enum {string}
         */
        simulationLogLevel:
          | "NOTHING"
          | "FATAL"
          | "ERROR"
          | "WARNING"
          | "INFO"
          | "VERBOSE"
          | "DEBUG"
          | "ALL";
      };
    }[];
    Model: (unknown | unknown) & {
      fmu?: {
        /**
         * @description Reference ID to the compiled model
         * @example workspace_pid_controller_20090615_134530_as86g32
         */
        id: string;
      };
      modelica?: {
        /**
         * @description Model class name
         * @example Modelica.Fluid.Examples.PumpingSystem
         */
        className: string;
        /**
         * @description Key-value pairs of compilation options
         * @default {
         *   "c_compiler": "gcc"
         * }
         * @example {
         *   "generate_html_diagnostics": true
         * }
         */
        compilerOptions: { [key: string]: number | string | boolean };
        /**
         * @description Key-value pairs of run-time options
         * @default {}
         * @example {
         *   "log_level": 4
         * }
         */
        runtimeOptions: { [key: string]: number | string | boolean };
        /**
         * @description Compiler log level
         * @default warning
         * @example info
         */
        compilerLogLevel: string;
        /**
         * @description Flavour of the FMU
         * @default me
         * @example me
         * @enum {string}
         */
        fmiTarget: "me" | "cs" | "me+cs";
        /**
         * @description Version of FMI for the FMU
         * @default 2.0
         * @example 2.0
         * @enum {string}
         */
        fmiVersion: "1.0" | "2.0";
        /**
         * @description Platform for FMU binary
         * @default auto
         * @example win64
         * @enum {string}
         */
        platform: "linux64" | "win32" | "win64" | "auto";
      };
    };
    ExperimentDefinition: {
      /**
       * @description Experiment version, should be '2'
       * @example 2
       */
      version: number;
      base: {
        model: components["schemas"]["Model"];
        modifiers?: components["schemas"]["Modifiers"];
        expansion?: components["schemas"]["Expansion"];
        analysis: components["schemas"]["Analysis"];
      };
      extensions?: components["schemas"]["Extensions"];
    };
    ExperimentMetaData: {
      /** @example workspace_pid_controller_20090615_134530_as86g32 */
      experiment_hash?: string;
      model_names?: string[];
      /** @example 1550836039 */
      created_epoch?: number;
      /** @example my label */
      label?: string;
      /**
       * @description Up to 2048 bytes of custom data to be associated with the experiment.
       * @example {
       *   "parametrizationFrom": "specification 3.4",
       *   "externalToolVersion": "9.0"
       * }
       */
      user_data?: { [key: string]: unknown };
    };
    ExternalResultUploadStatus: {
      data?: {
        /**
         * @description The ID of the result import
         * @example 2f036b9fab6f45c788cc466da327cc78workspace
         */
        id?: string;
        /**
         * @description current status of the upload
         * @example ready
         */
        status?: string;
        /** @description Data for access to the meta data for the given upload, only exists in response if the upload was successful. Use the field 'status' to see if this is the case. */
        data?: {
          /**
           * @description URI for the result resource
           * @example api/external-result/2f036b9fab6f45c788cc466da327cc78workspace
           */
          resourceUri?: string;
        };
        /** @description Error message if the upload fails, only exists if an error has occurred. Use the field 'status' to see if this is the case. */
        error?: {
          /**
           * @description Error message describing what went wrong
           * @example Could not upload given result file to the specified workspace. Could not read version number of the workspace 'my_workspace' or unsupported file type given.
           */
          message?: string;
          /**
           * @description Error code for identifying specific errors
           * @example 12015
           */
          code?: number;
        };
      };
    };
  };
  responses: {
    /** The request could not be processed. The request is most likely not correct. */
    BadRequest: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** The request could not be performed because of missing authentication. */
    Unauthenticated: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** The request could not be performed because the system is out of payed for floating seats. */
    OutOfSeats: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** Action is not allowed. Permissions might be insufficient. */
    LicenseError: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** The resource could not be found. Typically this means that a resource the request is referencing does not exists. Common resources are workspaces, libraries, model-executables and experiments. */
    ResourceCouldNotBeFound: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** The request could not be performed because there is a conflict. */
    Conflict: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** An internal server error. */
    UnexpectedError: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
  };
}

export interface operations {
  /** Can be used by client to check that the API is of a version it supports. The APIs version is semantic. */
  getAPIMetaData: {
    parameters: {};
    responses: {
      /** A JSON object consisting of the APIs meta data, most notably the semantic version of it. */
      200: {
        content: {
          "application/json": {
            /** @description The semantic version of this API */
            version?: string;
          };
        };
      };
      500: components["responses"]["UnexpectedError"];
    };
  };
  /** When the login succeeds, the response includes a cookie containing an access token which is used for further identification with the REST API. The login is managed by a third party authorization service. To authenticate against the REST API, an API key may be included in the optional request body. The API key can be created <a class="visible-link" href="/admin/keys">in the API key manager</a>. */
  login: {
    parameters: {
      query: {
        /** The OAuth grant type to use for the login, one of refresh_token or client_credentials (default) */
        grant_type?: string;
      };
    };
    responses: {
      /** The user is already logged in and the JWT is valid */
      200: {
        content: {
          "application/json": {
            /** @description A user identifier. */
            identifier?: string;
          };
        };
      };
      /** The user was logged in and a new JWT was created */
      201: {
        content: {
          "application/json": {
            /** @description A user identifier. */
            identifier?: string;
          };
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      500: components["responses"]["UnexpectedError"];
    };
    /** Optional request body for logging in with an API key. */
    requestBody: {
      content: {
        "application/json": {
          /**
           * @description An API key.
           * @example secret-api-key
           */
          secretKey?: string;
        };
      };
    };
  };
  /** The workspace ID in the returned object serve as unique IDs that can be used in other API calls to perform operations for a specific workspace. */
  getWorkspaces: {
    parameters: {};
    responses: {
      /** All workspaces meta-data and their IDs. The object meta-data contains the workspace id and if the workspace is a clone. */
      200: {
        content: {
          "application/json": {
            data: {
              items: components["schemas"]["Workspace"][];
            };
          };
        };
      };
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  /** If creating a workspace with a name already existing, this call will have no effect. Importing a workspace with a name already existing will give it a new name. */
  createWorkspace: {
    parameters: {};
    responses: {
      /** OK: Workspace added and ID of the workspace was returned. */
      200: {
        content: {
          "application/json": {
            /**
             * @description The ID of the imported workspace
             * @example my_workspace
             */
            id?: string;
          };
        };
      };
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      500: components["responses"]["UnexpectedError"];
    };
    /** The workspace that will be added to the system depends on the content type, application/json is used for creating a new workspace and multipart/form-data is used to import a workspace. */
    requestBody: {
      content: {
        "multipart/form-data": {
          /**
           * Format: binary
           * @description The zip-file
           * @example my_workspace.zip
           */
          file?: string;
        };
        "application/json": {
          /** @description Input for creating a new workspace */
          new: {
            /**
             * @description The name of the workspace to create
             * @example my_workspace
             */
            name: string;
          };
        };
      };
    };
  };
  /** Used when not a specific workspace should be deleted but rather all workspaces with some attribute. */
  deleteWorkspaces: {
    parameters: {
      query: {
        /** Filter clones */
        clones?: boolean;
      };
    };
    responses: {
      /** OK: The targeted workspaces have been deleted */
      200: unknown;
      /** OK: The targeted workspaces have been marked for deletion */
      202: unknown;
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  getWorkspaceId: {
    parameters: {
      path: {
        /** ID of the workspace */
        workspace: string;
      };
    };
    responses: {
      /** Workspace ID and its meta-data. The object meta-data contains the workspace id and if the workspace is a clone. */
      200: {
        content: {
          "application/json": components["schemas"]["Workspace"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  /** Can be called periodically on a cloned workspace a client is working against. This will inform the system that this workspace is not inactive and may not be deleted. */
  increaseClonedWorkspaceTimestamp: {
    parameters: {
      path: {
        /** ID of the workspace */
        workspace: string;
      };
    };
    responses: {
      /** OK: The timestamp was succesfully increased to the current time. */
      200: unknown;
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  deleteWorkspace: {
    parameters: {
      path: {
        /** ID of the workspace */
        workspace: string;
      };
    };
    responses: {
      /** OK: The workspace was deleted. */
      200: unknown;
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  /** The compressed workspace may be downloaded, after successful completion of a call to this endpoint, by calling GET /workspaces/{workspace}/exports/{exportId}. */
  prepareExportWorkspace: {
    parameters: {
      path: {
        /** ID of the workspace */
        workspace: string;
      };
    };
    responses: {
      /** OK: The ID used for downloading the compressed workspace and the size of the resulting zip file was returned. */
      200: {
        content: {
          "application/json": {
            /**
             * @description ID for downloading the compressed workspace
             * @example 79sd8-3n2a4-e3t24
             */
            export_id?: string;
            /**
             * @description The size of the compressed workspace, in bytes
             * @example 10481015
             */
            file_size?: number;
          };
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
    /** Specification of what workspace resources to included when exporting the workspace. */
    requestBody: {
      content: {
        "application/json": {
          contents: {
            /**
             * @description List of dictionaries, describing which libraries to include when downloading the workspace
             * @example [
             *   {
             *     "name": "LiquidCooling",
             *     "resources_to_exclude": []
             *   },
             *   {
             *     "name": "Workspace",
             *     "resources_to_exclude": [
             *       "my_plot.png",
             *       "my_sheet.csv"
             *     ]
             *   }
             * ]
             */
            libraries: {
              /**
               * @description The name of the library
               * @example LiquidCooling
               */
              name: string;
              /**
               * @description A list of resources to exclude when exporting library
               * @example [
               *   "my_plot.png",
               *   "my_sheet.csv"
               * ]
               */
              resources_to_exclude: string[];
            }[];
            /**
             * @description List of experiments to include when downloading the workspace
             * @example [
             *   "_nics_multibody_examples_elementary_doublependulum_20191029_084342_2c956e9",
             *   "modelica_blocks_examples_pid_controller_20191023_151659_f32a30d"
             * ]
             */
            experiment_ids: string[];
            /**
             * @description List of model executables to include when downloading the workspace
             * @example [
             *   "_nics_multibody_examples_elementary_doublependulum_20191029_084342_2c956e9",
             *   "modelica_blocks_examples_pid_controller_20191023_151659_f32a30d"
             * ]
             */
            fmu_ids: string[];
          };
        };
      };
    };
  };
  /** The workspace needs to be compressed by calling POST /workspaces/{workspace}/exports, before calling this API endpoint. */
  exportWorkspace: {
    parameters: {
      path: {
        /** ID of the workspace */
        workspace: string;
        /** ID of the compressed workspace to download */
        exportId: string;
      };
    };
    responses: {
      /** A zip file containing the workspace. */
      200: {
        content: {
          "application/zip": string;
        };
      };
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  /** This API end point can be be called after a compressed workspace has been downloaded. */
  deleteExportedWorkspace: {
    parameters: {
      path: {
        /** ID of the workspace */
        workspace: string;
        /** ID of the compressed workspace to download */
        exportId: string;
      };
    };
    responses: {
      /** OK: The workspace with the specified ID was deleted. */
      200: unknown;
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  /** A created clone of a workspace is a temporary resource. It can be used executing some workload based on resources of a workspace without mutating or adding anything to it. */
  cloneWorkspace: {
    parameters: {
      path: {
        /** ID of the workspace */
        workspace: string;
      };
    };
    responses: {
      /** OK: The workspace was cloned and the ID of the clone was returned. */
      200: {
        content: {
          "application/json": {
            /**
             * @description The name of the new cloned workspace
             * @example MyClonedWorkspace
             */
            workspace_id?: string;
          };
        };
      };
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  /** Get workspace dependencies. */
  getWorkspaceDependencies: {
    parameters: {
      path: {
        /** ID of the workspace */
        workspace: string;
      };
    };
    responses: {
      /** OK: The workspace dependencies were returned. */
      200: {
        content: {
          "application/json": {
            /**
             * @description Project id
             * @example 79sd8-3n2a4-e3t24
             */
            id?: string;
            /**
             * @description Project name
             * @example MyProject
             */
            name?: string;
            /** @description List of content objects. */
            content?: { [key: string]: unknown }[];
          };
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  /** Get workspace projects. */
  getWorkspaceProjects: {
    parameters: {
      path: {
        /** ID of the workspace */
        workspace: string;
      };
    };
    responses: {
      /** OK: The workspace projects were returned. */
      200: {
        content: {
          "application/json": {
            /**
             * @description Project id
             * @example 79sd8-3n2a4-e3t24
             */
            id?: string;
            /**
             * @description Project name
             * @example MyProject
             */
            name?: string;
            /** @description List of content objects. */
            content?: { [key: string]: unknown }[];
          };
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  /** top-level libraries are available for all workspaces. It does not return any meta data for libraries stored in specific workspaces. */
  getTopLevelLibraries: {
    parameters: {};
    responses: {
      /** A list of meta data for all top-level model libraries. */
      200: {
        content: {
          "application/json": {
            data?: {
              /** @description List of objects containing all top-level libraries and their metadata. */
              items?: { [key: string]: unknown }[];
            };
          };
        };
      };
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  getLibraries: {
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
      };
    };
    responses: {
      /** A list containing meta data for all libraries in the workspace. */
      200: {
        content: {
          "application/json": {
            data?: {
              items?: { [key: string]: unknown }[];
            };
          };
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  importLibrary: {
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
      };
    };
    responses: {
      /** The meta data for the added model library. */
      200: {
        content: {
          "application/json": {
            /**
             * @description The model library identifier
             * @example Modelon
             */
            name: string;
            /**
             * @description The model library dependencies
             * @example {
             *   "Modelica": "3.2.2",
             *   "ThermalPower": "1.14"
             * }
             */
            uses: { [key: string]: unknown };
            /**
             * @description File ending for the model library archive, either 'zip' or 'mol'
             * @example mol
             */
            archive?: string;
            /**
             * @description The version number of the model library
             * @example 1.0
             */
            version?: string;
          };
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
    /** The file containing the model library, of type .mo, .mol or .zip. */
    requestBody: {
      content: {
        "multipart/form-data": {
          /**
           * Format: binary
           * @description The file containing the model library.
           * @example Modelon 2.6.zip
           */
          file?: string;
        };
      };
    };
  };
  /** The accept head is used to specify if meta data or the library itself is returned. With the default accept header '*\/*' the libraries meta data will be returned. If changed to application/zip the library will be downloaded as a zip-file if the library is structured. For an unstructured library the acceptance header text/plain can be used to download it as a mo-file. */
  exportLibrary: {
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
        /** The library identifier, '{name} {version}' or '{name}' if version is missing */
        library: string;
      };
    };
    responses: {
      /** The file containing the model library */
      200: {
        content: {
          "application/json": { [key: string]: unknown };
          "application/zip": string;
          "text/plain": string;
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  deleteLibrary: {
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
        /** The library identifier, '{name} {version}' or '{name}' if version is missing */
        library: string;
      };
    };
    responses: {
      /** OK. */
      200: unknown;
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  importFMU: {
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
        /** The library identifier, '{name} {version}' or '{name}' if version is missing */
        library: string;
      };
    };
    responses: {
      /** OK. The FMU has been imported to the workspace. */
      200: {
        content: {
          "application/json": {
            /**
             * @description The modelica class path for the imported FMU
             * @example Workspace.PID_Controller.Model
             */
            fmuClassPath: string;
            /**
             * @description An array containing warnings generated during FMU import
             * @example [
             *   "Specified argument for 'top_level_inputs=['a']' does not match any variable"
             * ]
             */
            importWarnings?: string[];
            /**
             * @description Meta data for the library the FMU was imported to.
             * @example {
             *   "id": "Hydraulics 4.9",
             *   "version": "4.9",
             *   "uses": {},
             *   "name": "Hydraulics",
             *   "archive": "mol"
             * }
             */
            library?: { [key: string]: unknown };
          };
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
    /** The file with a .fmu extension and options to import. */
    requestBody: {
      content: {
        "multipart/form-data": {
          /**
           * Format: binary
           * @description The FMU file.
           * @example PID.fmu
           */
          file: string;
          /**
           * @description Import options
           * @default {}
           */
          options: {
            /**
             * @description Qualified name of generated class. By default, 'className' is set to the name of the library followed by a name based on the filename of the imported FMU.
             * @example Workspace.Modelica_Electrical_Spice3_Examples_Spice3BenchmarkRtlInverter
             */
            className?: string;
            /** @description Determines if any already existing files in the library should be overwritten. By default, the existing files are not overwritten. */
            overwrite?: boolean;
            /**
             * @description Specifies what variables from the FMU to include in the wrapper model. By default, all the variables will be included in the wrapper model.
             * @example [
             *   "variable1",
             *   "variable2"
             * ]
             */
            includePatterns?: string[];
            /**
             * @description Specifies what variables from the FMU to exclude in the wrapper model. By default, all the variables will be included in the wrapper model.
             * @example [
             *   "variable1",
             *   "variable2"
             * ]
             */
            excludePatterns?: string[];
            /**
             * @description Specify which variables in the imported FMU will be inputs in the created Modelica wrapper model. By default, all the inputs are kept as inputs
             * @example [
             *   "variable1",
             *   "variable2"
             * ]
             */
            topLevelInputs?: string[];
            /**
             * @description Specifies the value for the 'step size' parameter in the generated model. By default, the parameter is set to zero, which in turn means that the step size will be set during simulation based on simulation properties such as the time interval.
             * @example 0.1
             */
            stepSize?: number;
          };
        };
      };
    };
  };
  /** Gets the meta-data for a custom function describing which parameters the custom function accepts (read more about the response for details). Note that the system comes with default custom functions thar are always available. Furthermore, you can read more about custom functions and setting up the system with your own in the Modelon Impact help center. */
  getCustomFunction: {
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
        /** Name of the custom function */
        "custom-function": string;
      };
    };
    responses: {
      /** A custom function and its meta-data */
      200: {
        content: {
          "application/json": {
            /**
             * @description Custom function signature schema version
             * @example 0.0.1
             */
            version?: string;
            /**
             * @description Name of the custom function
             * @example my_custom_function
             */
            name?: string;
            /**
             * @description Description of the custom function
             * @example This is my custom function!
             */
            description?: string;
            /** @description Indicates whether the custom function support the 'initialize from' functionality when setting up an experiment. */
            can_initialize_from?: boolean;
            /** @description A list of parameters that should be supplied in the experiment definition if this custom function is used. */
            parameters?: {
              /**
               * @description Name of the custom function parameter
               * @example my_custom_function_parameter
               */
              name: string;
              /**
               * @description Data type of the custom function parameter, supported types are 'Number', 'String', 'Boolean' and 'Enumeration'
               * @example Number
               */
              type: string;
              /**
               * @description A list specifying values to choose the parameter from (applicable only for parameters of type Enumeration).
               * @example [
               *   "small",
               *   "medium",
               *   "large"
               * ]
               */
              values?: string[];
              /**
               * @description Description of the custom function parameter
               * @example This is my custom function parameter, supports values of '1', '2' and '3'
               */
              description: string;
              /**
               * @description If this custom function parameter is optional when calling this custom function, supported values are 'true' and 'false'
               * @example true
               */
              optional?: string;
              /**
               * @description Default value for this custom function parameter, its data type should be as specified in 'type' (except for enumeration parameters, where the default value should be one of the enumerated values).
               * @example 2
               */
              defaultValue?: string | number | boolean;
            }[];
          };
        };
      };
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  /** Gets the (aggregated) options for a custom function. This includes: Workspace specific options, options configured as defaults for the application, default options specified in the custom function. For options specified on multiple levels, the value is taken primarily from the workspace specific options, secondarily from the application default options and in third hand from the custom function default options. */
  getExecutionOptions: {
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
        /** Name of the custom function */
        "custom-function": string;
      };
    };
    responses: {
      /** The aggregated execution option set for a custom function */
      200: {
        content: {
          "application/json": components["schemas"]["CaseExecutionOptions"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  /** The values for the options are saved for a specific custom function and workspace. */
  putExecutionOptions: {
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
        /** Name of the custom function */
        "custom-function": string;
      };
    };
    responses: {
      /** OK. */
      200: unknown;
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
    /** Execution options to set for custom function */
    requestBody: {
      content: {
        "application/json": components["schemas"]["CaseExecutionOptions"];
      };
    };
  };
  /** Gets the application level default options for a custom function. This includes: Options configured as defaults for the application and default options specified in the custom function. For options specified on both levels, the value is taken from the application default options. */
  getDefaultExecutionOptions: {
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
        /** Name of the custom function */
        "custom-function": string;
      };
    };
    responses: {
      /** The application level default execution options for a custom function */
      200: {
        content: {
          "application/json": {
            /**
             * @description Compilation options
             * @example {
             *   "c_compiler": "gcc",
             *   "interactive_fmu": true,
             *   "expose_scalar_equation_blocks_in_interactive_fmu": true,
             *   "merge_blt_blocks": true,
             *   "hand_guided_tearing": true,
             *   "local_iteration_in_tearing": "annotation",
             *   "equation_sorting": true,
             *   "automatic_tearing": true,
             *   "divide_by_vars_in_tearing": true,
             *   "variability_propagation": false
             * }
             */
            compiler?: { [key: string]: unknown };
            /**
             * @description Run-time options
             * @example {}
             */
            runtime?: { [key: string]: unknown };
            /**
             * @description Simulation options
             * @example {}
             */
            simulation?: { [key: string]: unknown };
            /**
             * @description Solver options
             * @example {
             *   "max_iter_no_jacobian": 1,
             *   "tolerance": 0.00001,
             *   "step_limit_factor": 1,
             *   "jacobian_calculation_mode": 9,
             *   "residual_equation_scaling": 5
             * }
             */
            solver?: { [key: string]: unknown };
          };
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  /** Which custom functions that exists are useful when setting up an experiment using POST /workspaces/{workspace}/experiments. The name of a custom function is used for the field 'analysis_function' which specifies that it should be used for the experiment. The meta-data also describes which parameters each custom function accepts (read more about the response for details). Note that the system comes with default custom functions thar are always available. Furthermore, you can read more about custom functions and setting up the system with your own in the Modelon Impact help center. */
  getCustomFunctions: {
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
      };
    };
    responses: {
      /** A list of custom functions and their meta-data */
      200: {
        content: {
          "application/json": {
            data?: {
              items?: {
                /**
                 * @description Custom function signature schema version
                 * @example 0.0.1
                 */
                version: string;
                /**
                 * @description Name of the custom function
                 * @example my_custom_function
                 */
                name: string;
                /**
                 * @description Description of the custom function
                 * @example This is my custom function!
                 */
                description: string;
                /** @description Indicates whether the custom function support the 'initialize from' functionality when setting up an experiment. */
                can_initialize_from: boolean;
                /** @description A list of parameters that should be supplied in the experiment definition if this custom function is used. */
                parameters: {
                  /**
                   * @description Name of the custom function parameter
                   * @example my_custom_function_parameter
                   */
                  name: string;
                  /**
                   * @description Data type of the custom function parameter, supported types are 'Number', 'String', 'Boolean' and 'Enumeration'
                   * @example Number
                   */
                  type: string;
                  /**
                   * @description A list specifying values to choose the parameter from (applicable only for parameters of type Enumeration).
                   * @example [
                   *   "small",
                   *   "medium",
                   *   "large"
                   * ]
                   */
                  values?: string[];
                  /**
                   * @description Description of the custom function parameter
                   * @example This is my custom function parameter, supports values of '1', '2' and '3'
                   */
                  description: string;
                  /**
                   * @description If this custom function parameter is optional when calling this custom function, supported values are 'true' and 'false'
                   * @example true
                   */
                  optional?: string;
                  /**
                   * @description Default value for this custom function parameter, its data type should be as specified in 'type' (except for enumeration parameters, where the default value should be one of the enumerated values).
                   * @example 2
                   */
                  defaultValue?: string | number | boolean;
                }[];
              }[];
            };
          };
        };
      };
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  getUnitConversionFactors: {
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
      };
    };
    responses: {
      /** A dictionary specifying the unit conversion factors for SI units and for imperial units. */
      200: {
        content: {
          "application/json": {
            /** @description SI unit conversions */
            si?: {
              /** @example K */
              unit: string;
              /** @example degC */
              displayUnit: string;
              /** @example 1 */
              multiplier: number;
              /** @example -273.15 */
              offset: number;
            }[];
            /** @description Imperial unit conversions */
            imperial?: {
              /** @example K */
              unit: string;
              /** @example degF */
              displayUnit: string;
              /** @example 1.8 */
              multiplier: number;
              /** @example -459.67 */
              offset: number;
            }[];
          };
        };
      };
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  getAllModelExecutableInfo: {
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
      };
    };
    responses: {
      /** The results and run info for all compilations. The response objects contain the FMU ID and the additional fields are what would be returned from .../model-executables/{fmuId}. */
      200: {
        content: {
          "application/vnd.impact.model-executable.v2+json": {
            data?: {
              /** @description List of all model executables */
              items?: components["schemas"]["ModelExecutableRunInfoV2"][];
            };
          };
          "application/vnd.impact.model-executable.v1+json": {
            data?: {
              /** @description List of all model executables */
              items?: components["schemas"]["ModelExecutableRunInfoV1"][];
            };
          };
        };
      };
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  /** The name of the model to be compiled is specified by the field 'class_name'. The remaining fields in the input are options for the compilation process. For a reference of what options can be used in the field 'compiler_options' and 'runtime_option' see the OCT User's Guide, which can be found in the Modelon Impact help center. If the FMU should be executed in Impact (rather than exported) it is recommended that 'fmi_target' is 'me', 'fmi_version' is '2.0' and 'platform' is 'auto'. If this end-point is called with the query parameter 'getCached' set to true, then a previously compiled model executable is returned, if such an FMU exists. To get a cached model executable (FMU) there must exists a successfully compiled model executable that was compiled with the same inputs as in the current call. Furthermore, if the Modelica model for which the FMU compilation is requested has been changed in a structural way, or at least one of its dependent models have changed, then a cached FMU will not be returned. Setting non-structural parameters and making graphical changes to the Modelica model will not break the cache for its compiled FMU. */
  modelExecutableSetup: {
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
      };
      query: {
        /** If true, returns, if available, a reusable model executable previously compiled. Also returns any non-structural parameters to be set on it. */
        getCached?: string;
        /** If true, a cached FMU can be found even if the FMU was compiled with some non-structural parameters with unknown value. If this is the case, parametersMissing in the response will contain a list of these parameters and the caller should ensure to specify some values for these parameters when using the cached FMU. */
        allowNonStructuralMissing?: string;
      };
    };
    responses: {
      /** An identifier for the FMU being compiled (ID). */
      200: {
        content: {
          "application/json": {
            /**
             * @description A unique identifier for an FMU. Will be null if getCached=true and no cached FMU is available.
             * @example workspace_pid_controller_20090615_134530_as86g32
             */
            id?: string;
            /**
             * @description Parameter values to be set on the FMU referenced by the 'id', for it to represent current model setup. Empty if getCached=false.
             * @example {
             *   "inertia1.J": 2
             * }
             */
            parameters?: { [key: string]: unknown };
            /** @description Parameters to be set for the FMU referenced by the 'id', default value is otherwise not guaranteed to represent current model setup. Empty if getCached=false or allowNonStructuralMissing=false. */
            parametersMissing?: string[];
          };
        };
      };
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
    /** Compilation parameters */
    requestBody: {
      content: {
        "application/json": {
          /** @description The input for how the compilation was done */
          input: {
            /**
             * @description Model class name
             * @example Workspace.PID_Controller
             */
            class_name: string;
            /**
             * @description Key-value pairs of compilation options
             * @example {
             *   "generate_html_diagnostics": true
             * }
             */
            compiler_options: { [key: string]: number | string | boolean };
            /**
             * @description Key-value pairs of run-time options
             * @example {
             *   "log_level": 4
             * }
             */
            runtime_options: { [key: string]: number | string | boolean };
            /**
             * @description Compiler log level
             * @example info
             */
            compiler_log_level: string;
            /**
             * @description Flavour of the FMU
             * @example me
             * @enum {string}
             */
            fmi_target: "me" | "cs" | "me+cs";
            /**
             * @description Version of FMI for the FMU
             * @example 2.0
             * @enum {string}
             */
            fmi_version: "1.0" | "2.0";
            /**
             * @description Platform for FMU binary
             * @example win64
             * @enum {string}
             */
            platform: "linux64" | "win32" | "win64" | "auto";
          };
        };
      };
    };
  };
  /** Can be used to find which values are supported for the field 'platform' when calling the POST method on '/workspaces/{workspace}/model-executables' */
  getFmuPlatforms: {
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
      };
    };
    responses: {
      /** A list of the supported FMU's generation platforms */
      200: {
        content: {
          "application/json": {
            data?: {
              /**
               * @description An array containing the list of platforms in which the FMU can be generated
               * @example [
               *   "win32",
               *   "win64"
               * ]
               */
              platforms?: string[];
            };
          };
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  getModelExecutableInfo: {
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
        /** The FMU ID */
        fmuId: string;
      };
    };
    responses: {
      /** The result from a compilation. The 'status' and 'errors' in 'run_info' should be checked to see if compilation finished successfully. */
      200: {
        content: {
          "application/vnd.impact.model-executable.v2+json": components["schemas"]["ModelExecutableRunInfoV2"];
          "application/vnd.impact.model-executable.v1+json": components["schemas"]["ModelExecutableRunInfoV1"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  deleteModelExecutable: {
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
        /** The FMU ID */
        fmuId: string;
      };
    };
    responses: {
      /** OK. */
      200: unknown;
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  getCompilationStatus: {
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
        /** Reference ID to the model to be compiled */
        fmuId: string;
      };
    };
    responses: {
      /** Status of the compilation */
      200: {
        content: {
          "application/json": {
            /**
             * @description Number of executions that have finished. Should not be used for determining if an execution is finished, instead use the 'status' string.
             * @example 27
             */
            finished_executions?: number;
            /**
             * @description Total number of executions.
             * @example 50
             */
            total_executions?: number;
            /**
             * @description Execution status, can have the values 'pending', 'running', 'stopping', 'cancelled' or 'done'.
             * @example running
             */
            status?: string;
            /** @description An array containing progress information about all executions */
            progresses?: {
              /**
               * @description A message about the progress of the execution.
               * @example Simulation at time 3.45
               */
              message?: string;
              /**
               * @description A number between 0 and 1 indicating how the execution is progressing
               * @example 0.43
               */
              percentage?: number;
              /**
               * @description The stage this progress applies to. Possible values are 'simulation' and 'compilation'
               * @example compilation
               */
              stage?: string;
              /**
               * @description True if the compilation is done
               * @example true
               */
              done?: boolean;
            }[];
          };
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  /** First call POST /workspaces/{workspace}/model-executables to setup what should be compiled. */
  modelExecutableCompile: {
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
        /** Reference ID to the model to be compiled */
        fmuId: string;
      };
    };
    responses: {
      /** OK. */
      200: unknown;
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  cancelCompilation: {
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
        /** Reference ID to the model to be compiled */
        fmuId: string;
      };
    };
    responses: {
      /** OK. */
      200: unknown;
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  downloadCompilationLog: {
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
        /** Reference ID to the compiled model */
        fmuId: string;
      };
    };
    responses: {
      /** A compilation log */
      200: {
        content: {
          "text/plain": string;
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  downloadCompiledFMU: {
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
        /** Reference ID to the compiled model */
        fmuId: string;
      };
    };
    responses: {
      /** An FMU file */
      200: {
        content: {
          "application/zip": string;
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  getFmuMeta: {
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
        /** Reference ID to the compiled model */
        fmuId: string;
      };
    };
    responses: {
      /** The FMU meta-data */
      200: {
        content: {
          "application/json": {
            /** @description The steady state meta-data */
            steady_state?: {
              /**
               * @description Number of residual variables
               * @example 1
               */
              residual_variable_count?: number;
              /**
               * @description Number of iteration variables
               * @example 2
               */
              iteration_variable_count?: number;
            };
          };
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
    /** The current parameter state of the FMU */
    requestBody: {
      content: {
        "application/json": {
          /**
           * @description The current parameter state of the FMU
           * @example {
           *   "foo": 1,
           *   "bar": 2
           * }
           */
          parameterState: { [key: string]: unknown };
        };
      };
    };
  };
  /** Can be used to find what parameters are feasible to have as modifiers in an experiment. */
  getFmuParameters: {
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
        /** Reference ID to the compiled model */
        fmuId: string;
      };
    };
    responses: {
      /** A list of the FMU's settable parameters */
      200: {
        content: {
          "application/json": string[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  /** Gets a list of parameters whose values are strings and one list with respective value in order. Can be used when requiring string parameters that don't come with the result. */
  getFmuStringParametersAndValues: {
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
        /** Reference ID to the compiled model */
        fmuId: string;
      };
    };
    responses: {
      /** An object containing a list of two lists. The first list is the names of the parameters, and the second is a list of the parameter values in the same order */
      200: {
        content: {
          "application/json": {
            data?: {
              /**
               * @description An array containing two arrays, the first containing parameter names and the second containing respective string values
               * @example [
               *   [
               *     "var1",
               *     "var2"
               *   ],
               *   [
               *     "val1",
               *     "val2"
               *   ]
               * ]
               */
              items?: string[][];
            };
          };
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  getAllExperimentInfo: {
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
      };
    };
    responses: {
      /** The experiment setups and run info for all experiments. The objects contain the experiment ids, and additional values are what would be returned from .../experiments/{experimentId} */
      200: {
        content: {
          "application/vnd.impact.experiment.v2+json": {
            data?: {
              /** @description List of all experiments */
              items?: {
                /** @example workspace_pid_controller_20200705_170234_546ccba */
                id?: string;
                experiment?: components["schemas"]["ExperimentDefinition"];
                run_info?: {
                  /**
                   * @description String that is 'cancelled', 'failed' or 'done' depending on if all parts of the experiment could run
                   * @example failed
                   */
                  status?: string;
                  /**
                   * @description An array containing errors if status is 'failed'
                   * @example [
                   *   "Current settings will generate a large amount of simulation cases. Try reducing the number of simulation cases."
                   * ]
                   */
                  errors?: string[];
                  /**
                   * @description Number of cases that are failed
                   * @example 0
                   */
                  failed?: number;
                  /**
                   * @description Number of cases that are successful
                   * @example 15
                   */
                  successful?: number;
                  /**
                   * @description Number of cases that are not started
                   * @example 0
                   */
                  not_started?: number;
                  /**
                   * @description Number of cases that are cancelled
                   * @example 0
                   */
                  cancelled?: number;
                };
                meta_data?: components["schemas"]["ExperimentMetaData"];
              }[];
            };
          };
          "application/vnd.impact.experiment.v1+json": {
            data?: {
              /** @description List of all experiments */
              items?: {
                /** @example workspace_pid_controller_20200705_170234_546ccba */
                id?: string;
                experiment?: {
                  /**
                   * @description Reference ID to the compiled model
                   * @example workspace_pid_controller_20090615_134530_as86g32
                   */
                  fmu_id: string;
                  /**
                   * @example {
                   *   "variables": {
                   *     "integrator.k": 1,
                   *     "inertia1.J": "range(1,5,5)",
                   *     "inertia2.J": "range(5,10,3)"
                   *   },
                   *   "initializeFrom": ""
                   * }
                   */
                  modifiers?: {
                    /** @description Specifies parameter values and ranges. The range operator allows a range of values to be described: e.g. range(0,1,5) describes 5 evenly spaced values between 0 and 1: [0,0.25,0.5,0.75,1]. If multiple range operators are specified a full factorial is used to determine all different parameterizations for the experiment */
                    variables?: { [key: string]: number | string | boolean };
                    /** @description Initialize the simulation using values from a previous simulation by giving the corresponding experiment ID. The experiment used must be for a simulation with a single case, otherwise 'initializeFromCase' must be used. Details on how the initialization is done depend on the custom function */
                    initializeFrom?: string;
                  };
                  /** @description The analysis object */
                  analysis: {
                    /**
                     * @description The name of the custom function that will be executed
                     * @example dynamic
                     */
                    analysis_function: string;
                    /**
                     * @description Parameters to the custom function
                     * @example {
                     *   "start_time": 0,
                     *   "final_time": 1
                     * }
                     */
                    parameters?: { [key: string]: number | string | boolean };
                    /** @description Key-value pairs of simulation options */
                    simulation_options?: {
                      [key: string]: number | string | boolean;
                    };
                    /** @description Key-value pairs of solver options */
                    solver_options?: {
                      [key: string]: number | string | boolean;
                    };
                    /**
                     * @description The simulation log level
                     * @default WARNING
                     * @enum {string}
                     */
                    simulation_log_level:
                      | "NOTHING"
                      | "FATAL"
                      | "ERROR"
                      | "WARNING"
                      | "INFO"
                      | "VERBOSE"
                      | "DEBUG"
                      | "ALL";
                  };
                };
                run_info?: {
                  /**
                   * @description String that is 'cancelled', 'failed' or 'done' depending on if all parts of the experiment could run
                   * @example failed
                   */
                  status?: string;
                  /**
                   * @description An array containing errors if status is 'failed'
                   * @example [
                   *   "Current settings will generate a large amount of simulation cases. Try reducing the number of simulation cases."
                   * ]
                   */
                  errors?: string[];
                  /**
                   * @description Number of cases that are failed
                   * @example 0
                   */
                  failed?: number;
                  /**
                   * @description Number of cases that are successful
                   * @example 15
                   */
                  successful?: number;
                };
                meta_data?: components["schemas"]["ExperimentMetaData"];
              }[];
            };
          };
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  /**
   * The required inputs for setting up a multi-execution experiment is either 'id' in 'base/model/fmu' OR 'className' in 'base/model/modelica', along with 'type' in 'base/analysis'. These can be obtained from POST /workspaces/{workspace}/model-executables and GET /workspaces/{workspace}/custom-functions respectively. The FMU 'id' specifies what FMU the experiment is based on, and analysis 'type' specifies what analysis custom function is used for each case of the experiment. Furthermore, experiments support multi-execution, i.e., batch computations where each case executes a custom function. Multi-execution experiments can be set up in two ways.
   *
   * The first way to setup multi-execution experiments is to specify 'operators' for 'modifiers' which are applied to the base experiment. An example experiment for this could contain the 'modifiers': {'variables': {'x': 'range(1, 2, 3)'}}, which would result in a multi-execution experiment with three cases: x=1, x=1.5, and x=2. Note that if multiple 'operators' are used for different variables, the experiment will be expand to cases with all combinations of parametrizations, i.e., full factorial is used to expand the experiment. Here is a full example using the range operator to create cases:
   *
   * <pre>
   * {
   *   "experiment": {
   *     "version": 2,
   *     "base": {
   *       "model": {
   *         "fmu": {
   *           "id": "workspace_pid_controller_20090615_134530_as86g32"
   *         }
   *       },
   *       "modifiers": {
   *         "variables": {
   *           "inertia1.J": "range(1, 2, 10)",
   *         }
   *       },
   *       "analysis": {
   *         "type": "dynamic",
   *         "parameters": {
   *           "start_time": 0,
   *           "final_time": 1
   *         }
   *       }
   *     }
   *   }
   * }
   * </pre>
   *
   * The other way of defining an experiment is to specify 'extensions' to the 'base' definition, where each 'extension' is combined with 'base' to create a case. For example, an experiment with the 'extensions': [{'modifiers': {'variables': {'x': 1}}}, {'modifiers': {'variables': {'x': 1.5}}}, {'modifiers': {'variables': {'x': 2}}}], would result in the same multi-execution as above (if no modifiers are defined in 'base'). This way of creating cases gives more freedom to the client to set up a multi-execution experiment, since cases are defined by parameter configurations, as opposed to operators (like the range operator). This approach also allows different options and custom function parameters to be used for the different cases. These two methods of setting up a multi-execution cannot be combined. So, if any extensions are given, it is not allowed to include any 'operators' anywhere in the experiment. It is however allowed to provide parameter values (with no operators) in 'base' in combination with defining cases with 'extensions'. In this case, parameters set in 'extensions' overrides those set in 'base'.
   *
   * The following example shows how 'extensions' are used to set options and parameters for separate cases and thereby overriding the values in the 'base' definition. The 'base' definition in the example have 'analysis': {'type': 'dynamic', 'parameters': {'start_time': 2, 'final_time': 3}}, and 'modifiers': {'variables': {'x': 1, 'y': 3}}}. If used with the 'extensions':
   *
   * [{'analysis': {'parameters': {'final_time': 4}}}, 'modifiers': {'variables': {'y': 5}}}, {'analysis': {'parameters': {'start_time': 1}}}, 'modifiers': {'variables': {'x': 2}}}],
   *
   * we will get two cases. The first case will use 2 for 'start_time' from the 'base' and 4 for 'final_time' as it is overridden by the 'extension', in the same way it will use 'x'=1 and 'y'=5 as modifiers. The second case overrides 'start_time' and 'x' and will result in 'start_time'=1, 'final_time'=3, 'x'=2, and 'y'=3.
   *
   * The old (version 1) experiment format can still be used but will be removed in a future version.
   */
  setupExperiment: {
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
      };
    };
    responses: {
      /** An identifier for the experiment (ID). */
      200: {
        content: {
          "application/json": {
            /**
             * @description An object with an unique identifier for this experiment, used to track this experiment in other API calls.
             * @example workspace_pid_controller_20090615_134530_as86g32
             */
            experiment_id: string;
          };
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
    /** Experiment parameters */
    requestBody: {
      content: {
        "application/vnd.impact.experiment.v2+json": {
          experiment: components["schemas"]["ExperimentDefinition"];
          /**
           * @description Up to 2048 bytes of custom data to be associated with the experiment.
           * @example {
           *   "parametrizationFrom": "specification 3.4",
           *   "externalToolVersion": "9.0"
           * }
           */
          userData?: { [key: string]: unknown };
        };
        "application/vnd.impact.experiment.v1+json": {
          experiment: {
            /**
             * @description Reference ID to the compiled model
             * @example workspace_pid_controller_20090615_134530_as86g32
             */
            fmu_id: string;
            /**
             * @example {
             *   "variables": {
             *     "integrator.k": 1,
             *     "inertia1.J": "range(1,5,5)",
             *     "inertia2.J": "range(5,10,3)"
             *   },
             *   "initializeFrom": ""
             * }
             */
            modifiers?: {
              /** @description Specifies parameter values and ranges. The range operator allows a range of values to be described: e.g. range(0,1,5) describes 5 evenly spaced values between 0 and 1: [0,0.25,0.5,0.75,1]. If multiple range operators are specified a full factorial is used to determine all different parameterizations for the experiment */
              variables?: { [key: string]: number | string | boolean };
              /** @description Initialize the simulation using values from a previous simulation by giving the corresponding experiment ID. The experiment used must be for a simulation with a single case, otherwise 'initializeFromCase' must be used. Details on how the initialization is done depend on the custom function */
              initializeFrom?: string;
            };
            /** @description The analysis object */
            analysis: {
              /**
               * @description The name of the custom function that will be executed
               * @example dynamic
               */
              analysis_function: string;
              /**
               * @description Parameters to the custom function
               * @example {
               *   "start_time": 0,
               *   "final_time": 1
               * }
               */
              parameters?: { [key: string]: number | string | boolean };
              /** @description Key-value pairs of simulation options */
              simulation_options?: { [key: string]: number | string | boolean };
              /** @description Key-value pairs of solver options */
              solver_options?: { [key: string]: number | string | boolean };
              /**
               * @description The simulation log level
               * @default WARNING
               * @enum {string}
               */
              simulation_log_level:
                | "NOTHING"
                | "FATAL"
                | "ERROR"
                | "WARNING"
                | "INFO"
                | "VERBOSE"
                | "DEBUG"
                | "ALL";
            };
          };
          /**
           * @description Up to 2048 bytes of custom data to be associated with the experiment.
           * @example {
           *   "parametrizationFrom": "specification 3.4",
           *   "externalToolVersion": "9.0"
           * }
           */
          userData?: { [key: string]: unknown };
        };
      };
    };
  };
  getExperimentInfo: {
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
        /** The ID of the experiment */
        experimentId: string;
      };
    };
    responses: {
      /** The experiment information as JSON */
      200: {
        content: {
          "application/vnd.impact.experiment.v2+json": {
            /** @example workspace_pid_controller_20200705_170234_546ccba */
            id?: string;
            experiment?: components["schemas"]["ExperimentDefinition"];
            meta_data?: components["schemas"]["ExperimentMetaData"];
            run_info?: {
              /**
               * @description String that is 'cancelled', 'failed' or 'done' depending on if all parts of the experiment could run
               * @example failed
               */
              status?: string;
              /**
               * @description An array containing errors if status is 'failed'
               * @example [
               *   "Current settings will generate a large amount of simulation cases. Try reducing the number of simulation cases."
               * ]
               */
              errors?: string[];
              /**
               * @description Number of cases that are failed
               * @example 0
               */
              failed?: number;
              /**
               * @description Number of cases that are successful
               * @example 2
               */
              successful?: number;
              /**
               * @description Number of cases that are not started
               * @example 0
               */
              not_started?: number;
              /**
               * @description Number of cases that are cancelled
               * @example 0
               */
              cancelled?: number;
            };
          };
          "application/vnd.impact.experiment.v1+json": {
            /** @example workspace_pid_controller_20200705_170234_546ccba */
            id?: string;
            experiment?: {
              /**
               * @description Reference ID to the compiled model
               * @example workspace_pid_controller_20090615_134530_as86g32
               */
              fmu_id: string;
              /**
               * @example {
               *   "variables": {
               *     "integrator.k": 1,
               *     "inertia1.J": "range(1,5,5)",
               *     "inertia2.J": "range(5,10,3)"
               *   },
               *   "initializeFrom": ""
               * }
               */
              modifiers?: {
                /** @description Specifies parameter values and ranges. The range operator allows a range of values to be described: e.g. range(0,1,5) describes 5 evenly spaced values between 0 and 1: [0,0.25,0.5,0.75,1]. If multiple range operators are specified a full factorial is used to determine all different parameterizations for the experiment */
                variables?: { [key: string]: number | string | boolean };
                /** @description Initialize the simulation using values from a previous simulation by giving the corresponding experiment ID. The experiment used must be for a simulation with a single case, otherwise 'initializeFromCase' must be used. Details on how the initialization is done depend on the custom function */
                initializeFrom?: string;
              };
              /** @description The analysis object */
              analysis: {
                /**
                 * @description The name of the custom function that will be executed
                 * @example dynamic
                 */
                analysis_function: string;
                /**
                 * @description Parameters to the custom function
                 * @example {
                 *   "start_time": 0,
                 *   "final_time": 1
                 * }
                 */
                parameters?: { [key: string]: number | string | boolean };
                /** @description Key-value pairs of simulation options */
                simulation_options?: {
                  [key: string]: number | string | boolean;
                };
                /** @description Key-value pairs of solver options */
                solver_options?: { [key: string]: number | string | boolean };
                /**
                 * @description The simulation log level
                 * @default WARNING
                 * @enum {string}
                 */
                simulation_log_level:
                  | "NOTHING"
                  | "FATAL"
                  | "ERROR"
                  | "WARNING"
                  | "INFO"
                  | "VERBOSE"
                  | "DEBUG"
                  | "ALL";
              };
            };
            meta_data?: components["schemas"]["ExperimentMetaData"];
            run_info?: {
              /**
               * @description String that is 'cancelled', 'failed' or 'done' depending on if all parts of the experiment could run
               * @example failed
               */
              status?: string;
              /**
               * @description An array containing errors if status is 'failed'
               * @example [
               *   "Current settings will generate a large amount of simulation cases. Try reducing the number of simulation cases."
               * ]
               */
              errors?: string[];
              /**
               * @description Number of cases that are failed
               * @example 0
               */
              failed?: number;
              /**
               * @description Number of cases that are successful
               * @example 2
               */
              successful?: number;
            };
          };
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  /** Can be used to set a human readable identifier for an experiment. */
  setLabel: {
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
        /** The ID of the experiment */
        experimentId: string;
      };
    };
    responses: {
      /** OK. */
      200: unknown;
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
    /** The new label for the experiment */
    requestBody: {
      content: {
        "application/json": {
          /**
           * @description The new label for the experiment
           * @example tuning of P part
           */
          label: string;
        };
      };
    };
  };
  removeExperiment: {
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
        /** The ID of the experiment */
        experimentId: string;
      };
    };
    responses: {
      /** OK. */
      200: unknown;
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  getExecutionStatus: {
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
        /** The ID of the experiment */
        experimentId: string;
      };
    };
    responses: {
      /** Status */
      200: {
        content: {
          "application/json": {
            /**
             * @description Number of executions that have finished. Should not be used for determining if an execution is finished, instead use the 'status' string.
             * @example 27
             */
            finished_executions?: number;
            /**
             * @description Total number of executions.
             * @example 50
             */
            total_executions?: number;
            /**
             * @description Execution status, can have the values 'pending', 'running', 'stopping', 'cancelled' or 'done'.
             * @example running
             */
            status?: string;
            /** @description An array containing progress information about all executions */
            progresses?: {
              /**
               * @description A messag about the progress of the exectuion.
               * @example Simulation at time 3.45
               */
              message?: string;
              /**
               * @description A number between 0 and 1 indicating how the execution is progressing
               * @example 0.43
               */
              percentage?: number;
              /**
               * @description The stage this progress applies to. Possible values are 'simulation' and 'compilation'
               * @example compilation
               */
              stage?: string;
              /**
               * @description True if the execution is done
               * @example true
               */
              done?: boolean;
            }[];
          };
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  /** First call POST /workspaces/{workspace}/experiments to setup what should be executed. */
  execute: {
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
        /** The ID of the experiment */
        experimentId: string;
      };
    };
    responses: {
      /** The experiment is executed */
      200: unknown;
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
    /** Optional request body for how execution should run */
    requestBody: {
      content: {
        "application/json": {
          /** @description The cases to include in the execution */
          includeCases?: {
            /** @description List of cases to execute */
            ids?: string[];
          };
          /** @description Options for how the execution is run */
          options?: {
            /**
             * @description If true, then compilation will always be done even if a previous compilation result could be used. Default is false
             * @example true
             */
            forceCompilation?: boolean;
          };
        };
      };
    };
  };
  cancelExecution: {
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
        /** The ID of the experiment */
        experimentId: string;
      };
    };
    responses: {
      /** The experiment is cancelled */
      200: unknown;
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  getAllCaseInfo: {
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
        /** The ID of the experiment */
        experimentId: string;
      };
    };
    responses: {
      /** The case information as JSON */
      200: {
        content: {
          "application/json": {
            data?: {
              items?: {
                /**
                 * @description Case ID.
                 * @example case_1
                 */
                id?: string;
                meta?: {
                  /**
                   * @description Case label
                   * @example Cruise operating point
                   */
                  label?: unknown;
                };
                run_info?: {
                  /**
                   * @description Status of the case run, can be 'successful', 'failed', 'not_started' or 'cancelled'
                   * @example successful
                   */
                  status?: string;
                  /**
                   * @description At which stage the case failed if 'status' is 'failed', can be 'simulation' or 'compilation'. If 'status' is not 'failed' it will be null
                   * @example simulation
                   */
                  failed_at?: string;
                  /**
                   * @description The unix time the case started running
                   * @example 1549552749
                   */
                  datetime_started?: number;
                  /**
                   * @description The unix time the case finshed running
                   * @example 1549552338
                   */
                  datetime_finished?: number;
                };
                input?: {
                  /**
                   * @description Reference ID to the compiled model used running the case
                   * @example workspace_pid_controller_20090615_134530_as86g32
                   */
                  fmu_id?: string;
                  /** @description The analysis object */
                  analysis?: {
                    /**
                     * @description the name of the custom function
                     * @example dynamic
                     */
                    analysis_function: string;
                    /**
                     * @description parameters to the custom function
                     * @example {
                     *   "start_time": 0,
                     *   "final_time": 1
                     * }
                     */
                    parameters?: { [key: string]: unknown };
                    /** @description Key-value pairs of simulation options */
                    simulation_options?: { [key: string]: unknown };
                    /** @description Key-value pairs of solver options */
                    solver_options?: { [key: string]: unknown };
                  };
                  /** @description Parameterization of the case, a list of key value pairs where key is variable name and value is the value to use for that variable */
                  parametrization?: { [key: string]: unknown };
                  /** @description Structural parameterization of the case, a list of key value pairs where key is variable name and value is the value to use for that variable. These are values that cannot be applied to the FMU/Model after compilation */
                  structural_parametrization?: { [key: string]: unknown };
                  /** @description This is some base parametrization that must be applied to the FMU for it to be valid running this case. It often comes as a result from of caching to reuse the FMU */
                  fmu_base_parametrization?: { [key: string]: unknown };
                };
              }[];
            };
          };
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  getCaseInfo: {
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
        /** The ID of the experiment */
        experimentId: string;
        /** The ID of the case */
        caseId: string;
      };
    };
    responses: {
      /** Case information */
      200: {
        content: {
          "application/json": components["schemas"]["Case"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  /** This end-point can be used to update a case input. This can be used to modify the case and then execute the case again as part of an experiment and get different results for the case. Only fields under 'input' and 'meta' can be updated. Also, the fields 'fmu_id', 'analysis_function', 'structural_parametrization' and 'fmu_base_parametrization' cannot be updated. After a case is updated the 'consistent' field will be set to 'false' to signify that case results might not match the case input. Executing the case as part of an experiment will set 'consistent' to 'true'. The recomended way to update the case is to first use the corresponding GET end-point, modify some data, then call PUT (this end-point) with that data. */
  putCaseInfo: {
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
        /** The ID of the experiment */
        experimentId: string;
        /** The ID of the case */
        caseId: string;
      };
    };
    responses: {
      /** The case is updated */
      200: unknown;
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
    /** Case information */
    requestBody: {
      content: {
        "application/json": components["schemas"]["Case"];
      };
    };
  };
  getCaseLog: {
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
        /** The ID of the simulation */
        experimentId: string;
        /** The ID of the case */
        caseId: string;
      };
    };
    responses: {
      /** The case log. */
      200: {
        content: {
          "text/plain": string;
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  getCaseResults: {
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
        /** The ID of the experiment */
        experimentId: string;
        /** The ID of the case */
        caseId: string;
      };
    };
    responses: {
      /** A file containing the experiment result for this case */
      200: {
        content: {
          "application/vnd.impact.mat.v1+octet-stream": string;
          "text/csv": string;
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  /** This end-point can be used to fetch trajectories from cases that have finished executing. The trajectories are then typically used to visualize the result by plotting variables as a function of time or as X-Y plots. Which variables exists in a result can be obtained from the end-point GET /workspaces/{workspace}/experiments/{experimentId}/variables. Most experiments contain the independent variable 'time', with the custom function 'dynamic' being a notable example of this. So, to plot 'x' against 'time' for an experiment with a single case and the custom function 'dynamic', call this end-point with the input {'variable_names': ['x', 'time']} and plot 'item' 1 against 'item' 2 from the response. See the response description for more details on the structure of the response. The old (version 1) trajectory format can still be used but will be removed in a future version. */
  getCaseTrajectories: {
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
        /** The ID of the experiment */
        experimentId: string;
        /** The ID of the case */
        caseId: string;
      };
      query: {
        /** If true, converts the values 'Infinity', '-Infinity' and 'NaN' to strings before returning the response. */
        asStrings?: string;
      };
    };
    responses: {
      /** Experiment results for each variable in request body. */
      200: {
        content: {
          "application/vnd.impact.trajectories.v2+json": {
            data?: {
              items?: {
                /**
                 * @description If true, the trajectory does not vary with 'time' and only a single value is returned.
                 * @example false
                 */
                fixed?: boolean;
                /**
                 * @description The result trajectory for a variable, is an array of values.
                 * @example [
                 *   1,
                 *   2,
                 *   3,
                 *   4
                 * ]
                 */
                trajectory?: (Partial<number> & Partial<string>)[];
              }[];
            };
          };
          "application/vnd.impact.trajectories.v1+json": (Partial<number> &
            Partial<string>)[][];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
    /** A list of variable names for which the trajectories should be returned */
    requestBody: {
      content: {
        "application/json": {
          /**
           * @description The variable names trajectories should be fetched for
           * @example [
           *   "variable1",
           *   "variable2"
           * ]
           */
          variable_names: string[];
        };
      };
    };
  };
  getCustomArtifact: {
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
        /** The ID of the experiment */
        experimentId: string;
        /** The ID of the case */
        caseId: string;
        /** The ID of the artifact */
        artifactId: string;
      };
    };
    responses: {
      /** An artifact for this case */
      200: {
        content: {
          "application/octet-stream": string;
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  getVariables: {
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
        /** The ID of the experiment */
        experimentId: string;
      };
    };
    responses: {
      /** An array of variable names */
      200: {
        content: {
          "application/json": string[];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  /** This end-point can be used to fetch trajectories from experiments that has finished executing. The trajectories are then typically used to visualize the result by plotting variables as a function of time or as X-Y plots. Which variables exists in a result can be obtained from the end-point GET /workspaces/{workspace}/experiments/{experimentId}/variables. Most experiments contain the independent variable 'time', with the custom function 'dynamic' being a notable example of this. So, to plot 'x' against 'time' for an experiment with a single case and the custom function 'dynamic', call this end-point with the input {'variable_names': ['x', 'time']} and plot 'item' 1 against 'item' 2 under 'case_1' in the response. See the response description for more details on the structure of the response. The old (version 1) trajectory format can still be used but will be removed in a future version. */
  getTrajectories: {
    parameters: {
      path: {
        /** Name of the workspace */
        workspace: string;
        /** The ID of the experiment */
        experimentId: string;
      };
      query: {
        /** If true, converts the values 'Infinity', '-Infinity' and 'NaN' to strings before returning the response. */
        asStrings?: string;
      };
    };
    responses: {
      /** Experiment results for all cases of experiment and for each variable in request body. */
      200: {
        content: {
          "application/vnd.impact.trajectories.v2+json": {
            data?: {
              items?: {
                /**
                 * @description The case ID for which corresponding data in 'items' belong to.
                 * @example case_1
                 */
                caseId?: string;
                /** @description Trajectories for all variables given in request body for one case. */
                items?: {
                  /**
                   * @description If true, the trajectory does not vary with 'time' and only a single value is returned.
                   * @example false
                   */
                  fixed?: boolean;
                  /**
                   * @description The result trajectory for a variable, is an array of values.
                   * @example [
                   *   1,
                   *   2,
                   *   3,
                   *   4
                   * ]
                   */
                  trajectory?: (Partial<number> & Partial<string>)[];
                }[];
              }[];
            };
          };
          "application/vnd.impact.trajectories.v1+json": (Partial<number> &
            Partial<string>)[][][];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
    /** A list of variable names for which the trajectories should be returned */
    requestBody: {
      content: {
        "application/json": {
          /**
           * @description The variable names trajectories should be fetched for
           * @example [
           *   "variable1",
           *   "variable2"
           * ]
           */
          variable_names: string[];
        };
      };
    };
  };
  /** The compressed workspace will be prepared. After a successful completion of a call to this endpoint, call GET /workspace-exports/{exportId} to check status. */
  prepareExportWorkspaceAsync: {
    parameters: {};
    responses: {
      /** The location for checking status and possible data for compressed workspace */
      201: {
        content: {
          "application/json": {
            data?: {
              /**
               * @description location for checking status of workspace compression
               * @example api/workspace-exports/79sd8-3n2a4-e3t24
               */
              location?: string;
            };
          };
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
    /** Specification of what workspace resources to include when exporting the workspace. */
    requestBody: {
      content: {
        "application/json": {
          /**
           * @description The ID for the workspace to export
           * @example my_workspace
           */
          workspaceId: string;
          contents: {
            /**
             * @description List of dictionaries, describing which libraries to include when downloading the workspace
             * @example [
             *   {
             *     "name": "LiquidCooling",
             *     "resources_to_exclude": []
             *   },
             *   {
             *     "name": "Workspace",
             *     "resources_to_exclude": [
             *       "my_plot.png",
             *       "my_sheet.csv"
             *     ]
             *   }
             * ]
             */
            libraries: {
              /**
               * @description The name of the library
               * @example LiquidCooling
               */
              name: string;
              /**
               * @description A list of resources to exclude when exporting library
               * @example [
               *   "my_plot.png",
               *   "my_sheet.csv"
               * ]
               */
              resources_to_exclude: string[];
            }[];
            /**
             * @description List of experiments to include when downloading the workspace
             * @example [
             *   "_nics_multibody_examples_elementary_doublependulum_20191029_084342_2c956e9",
             *   "modelica_blocks_examples_pid_controller_20191023_151659_f32a30d"
             * ]
             */
            experiment_ids: string[];
            /**
             * @description List of model executables to include when downloading the workspace
             * @example [
             *   "_nics_multibody_examples_elementary_doublependulum_20191029_084342_2c956e9",
             *   "modelica_blocks_examples_pid_controller_20191023_151659_f32a30d"
             * ]
             */
            fmu_ids: string[];
            /** @description If field exists, workspace is exported as a read only dashboard workspace */
            dashboard?: {
              /**
               * @description The model to view in the dashboard workspace
               * @example Modelica.Blocks.Examples.PID_Controller
               */
              model: string;
            };
          };
        };
      };
    };
  };
  /** The workspace needs to be setup for export by calling POST /workspace-exports, before calling this API endpoint. */
  exportWorkspaceAsync: {
    parameters: {
      path: {
        /** ID of the compressed workspace to check status on */
        exportId: string;
      };
    };
    responses: {
      /** Status for a workspace export and data to download it if ready. */
      200: {
        content: {
          "application/json": {
            data?: {
              /**
               * @description ID for workspace export
               * @example 79sd8-3n2a4-e3t24
               */
              id?: string;
              /** @description Will be 'running' if export is on-going, 'ready' if export is finished and can be downloaded, or 'error' if an error occured. */
              status?: string;
              /** @description Data for the workspace to download, only exists in response if workspace is ready to be downloaded. Use the field 'status' to see if this is the case. */
              data?: {
                /**
                 * @description URI for downloading the workspace
                 * @example api/exports/79sd8-3n2a4-e3t24
                 */
                downloadUri?: string;
                /**
                 * @description The size of the compressed workspace, in bytes
                 * @example 10481015
                 */
                size?: number;
              };
              /** @description Error message if the export fails, only exists if an error has occurred. Use the field 'status' to see if this is the case. */
              error?: {
                /**
                 * @description Error message describing what went wrong
                 * @example Could not export workspace 'my_workspace'. Maximum allowed zip file size of 95MB exceeded
                 */
                message?: string;
                /**
                 * @description Error code for identifying specific errors
                 * @example 12072
                 */
                code?: number;
              };
            };
          };
        };
      };
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  /** This API end point can be be called after a compressed workspace has been downloaded. */
  deleteExportedWorkspaceAsync: {
    parameters: {
      path: {
        /** ID of the compressed workspace to check status on */
        exportId: string;
      };
    };
    responses: {
      /** OK: The workspace export with the specified ID was deleted. */
      200: unknown;
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  /** Will initiate import of an existing workspace. After a successful completion of a call to this endpoint, call GET /workspace-imports/{importId} to check status. */
  importWorkspace: {
    parameters: {};
    responses: {
      /** Workspace import created and location to check status of import is returned. */
      201: {
        content: {
          "application/json": {
            data?: {
              /**
               * @description The ID of the workspace import
               * @example api/workspace-imports/fd90-4gkl-vf89
               */
              location?: string;
            };
          };
        };
      };
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      500: components["responses"]["UnexpectedError"];
    };
    /** A zip file of a workspace given with multipart/form-data is used to import a workspace. */
    requestBody: {
      content: {
        "multipart/form-data": {
          /**
           * Format: binary
           * @description The zip-file
           * @example my_workspace.zip
           */
          file?: string;
        };
      };
    };
  };
  /** The workspace needs to be setup for import by calling POST /workspace-imports, before calling this API endpoint. */
  importWorkspaceStatus: {
    parameters: {
      path: {
        /** ID of the workspace import to check status on */
        importId: string;
      };
    };
    responses: {
      /** Status for a workspace import and data to resource if import is done and workspace is ready to be used. */
      200: {
        content: {
          "application/json": {
            data?: {
              /**
               * @description ID for workspace import
               * @example 79sd8-3n2a4-e3t24
               */
              id?: string;
              /** @description Will be 'running' if import is on-going, 'ready' if import is finished and can be used, or 'error' if an error occured. */
              status?: string;
              /** @description Data for the workspace imported, only exists in response if workspace is imported and ready to use. Use the field 'status' to see if this is the case. */
              data?: {
                /**
                 * @description URI for the imported workspace resource
                 * @example api/workspaces/my_workspace
                 */
                resourceUri?: string;
                /**
                 * @description The ID for the workspace imported
                 * @example my_workspace
                 */
                workspaceId?: string;
              };
              /** @description Error message if the import fails, only exists if an error has occurred. Use the field 'status' to see if this is the case. */
              error?: {
                /**
                 * @description Error message describing what went wrong
                 * @example Could not import workspace 'my_workspace'. Could not read version number of the workspace 'my_workspace'. Either the workspace is corrupt or needs to be updated using an older version of Modelon Impact
                 */
                message?: string;
                /**
                 * @description Error code for identifying specific errors
                 * @example 12015
                 */
                code?: number;
              };
            };
          };
        };
      };
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  /** This API end point can be be called after a workspace has been imported. */
  deleteWorkspaceImport: {
    parameters: {
      path: {
        /** ID of the workspace import to check status on */
        importId: string;
      };
    };
    responses: {
      /** OK: The workspace import with the specified ID was deleted. */
      200: unknown;
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  /** This route is used for downloading exported files. Other end-points will reference here with a download URI */
  exportFile: {
    parameters: {
      path: {
        /** ID of the compressed workspace to download */
        exportId: string;
      };
    };
    responses: {
      /** A file to download. */
      200: {
        content: {
          "application/zip": string;
        };
      };
      /** The resource cannot be downloaded. Most likely, something went wrong when creating the zip file */
      400: {
        content: {
          "application/json": {
            error?: {
              /**
               * @description Error message describing what went wrong
               * @example Could not export workspace 'ceb6ac1ed71040eb8f3df7f69157e658', reason: 'Maximum allowed zip file size of 95MB exceeded'
               */
              message?: string;
              /**
               * @description Error code for identifying specific errors
               * @example 12072
               */
              code?: number;
            };
          };
        };
      };
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  uploadMAT: {
    parameters: {};
    responses: {
      /** OK. The result has been uploaded to the workspace. */
      201: {
        content: {
          "application/json": components["schemas"]["ExternalResultUploadStatus"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
    /** The file with a .mat extension and options to import. */
    requestBody: {
      content: {
        "multipart/form-data": {
          /**
           * Format: binary
           * @description The result file in question.
           * @example result_1.mat
           */
          file: string;
          /** @description Upload options */
          options: {
            /**
             * @description Meaningful label for results association. If not given the name of the file uploaded will be used
             * @example result_for_PID.mat
             */
            name?: string;
            /**
             * @description Description of the result. If not given an empty string will be used
             * @example This is a result file for PID controller
             */
            description?: string;
            /** @description Context describing the model and associated values */
            context: {
              /**
               * @description Workspace id
               * @example my_workspace
               */
              workspaceId: string;
            };
          };
        };
      };
    };
  };
  /** Get the current status of upload for a given uploadId */
  getUploadStatus: {
    parameters: {
      path: {
        /** Id for result storage */
        uploadId: string;
      };
    };
    responses: {
      /** OK. Check status of upload. */
      200: {
        content: {
          "application/json": components["schemas"]["ExternalResultUploadStatus"];
        };
      };
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  /** Gets the meta-data for a result file */
  getUploadedResultEntity: {
    parameters: {
      path: {
        /** Id for result storage */
        uploadId: string;
      };
    };
    responses: {
      /** External result meta-data */
      200: {
        content: {
          "application/json": {
            data?: {
              /**
               * @description Id for result storage
               * @example 2f036b9fab6f45c788cc466da327cc78workspace
               */
              id?: string;
              /**
               * @description Timestamp of when the external result was imported
               * @example 2021-09-02T08:26:49.612000
               */
              createdAt?: string;
              /**
               * @description Meaningful label for results association
               * @example result_for_PID
               */
              name?: string;
              /**
               * @description Description of the result
               * @example This is a result file for PID controller
               */
              description?: string;
              /**
               * @description Name of workspace
               * @example workspace
               */
              workspaceId?: string;
            };
          };
        };
      };
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  deleteUploadedResultEntity: {
    parameters: {
      path: {
        /** Id for result storage */
        uploadId: string;
      };
    };
    responses: {
      /** OK. */
      200: unknown;
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  /** Returns the ID of the current user, which is used to create API keys, and the external IDs connected to it. */
  getCurrentUser: {
    parameters: {};
    responses: {
      200: {
        content: {
          "application/json": {
            data?: {
              /**
               * @description The user ID.
               * @example 2bb76154701c47c38d1950ea60d2c025
               */
              id: string;
              /** @description List of external IDs that are connected to this user ID. */
              externalUsers?: {
                /**
                 * @description ExternalID
                 * @example name@company.com
                 */
                id?: string;
              }[];
              /**
               * @description The users license. If field is missing the user does not have a license.
               * @example impact-pro
               * @enum {string}
               */
              license?: "impact-pro" | "impact-base" | "impact-deployment";
            };
          };
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  /** Get information on the API keys belonging to the user by the given ID. The information includes the key ID and the creation time but not the secret key itself. */
  getAPIkeys: {
    parameters: {
      path: {
        /** ID of the user */
        userId: string;
      };
    };
    responses: {
      /** Information about existing API keys. */
      200: {
        content: {
          "application/json": {
            data?: {
              items?: {
                /**
                 * @description The ID of the key
                 * @example zPY1U0KuBP
                 */
                id?: string;
                /**
                 * @description Timestamp of when the key was created
                 * @example 1588016253
                 */
                createdAt?: number;
              }[];
            };
          };
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  /** Creates a new API key belonging to the user with the given ID. The response contains a new API key which is the only time this key can be retrieved. They key must be safely stored by the recepient, as there is no way to retrieve it at a later point. A user may only have one API key at a time, so if it is lost or compromised, it must be deleted before a new one can be created. The API key can be used with the /login endpoint to log in. Each key has an ID to identify it when deleting it. */
  postAPIkey: {
    parameters: {
      path: {
        /** ID of the user */
        userId: string;
      };
    };
    responses: {
      /** OK: A new API key has been created. */
      200: {
        content: {
          "application/json": {
            data?: {
              /**
               * @description The API key ID.
               * @example zPY1U0KuBP
               */
              id?: string;
              /**
               * @description The API key.
               * @example secret-api-key
               */
              secret?: string;
              /**
               * @description The timestamp of when the key was created.
               * @example 1588016253
               */
              created_at?: number;
            };
          };
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  /** Deletes an API key with the given ID, belonging to a specified user. */
  deleteAPIKey: {
    parameters: {
      path: {
        /** ID of the user owning the key */
        userId: string;
        /** ID of the API key */
        keyId: string;
      };
    };
    responses: {
      /** OK: The API key was deleted. */
      200: unknown;
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      500: components["responses"]["UnexpectedError"];
    };
  };
  /** Validates an API key. */
  validateAPIKey: {
    responses: {
      /** Information about the user who owns the API key. */
      200: {
        content: {
          "application/json": {
            data?: {
              /**
               * @description The user ID of the owner of the key.
               * @example 2bb76154701c47c38d1950ea60d2c025
               */
              id?: string;
            };
          };
        };
      };
      /** The provided API key is invalid. */
      400: {
        content: {
          "application/json": {
            error?: {
              /**
               * @description Error message describing what went wrong
               * @example The provided API key is not valid
               */
              message?: string;
              /**
               * @description Error code for identifying specific errors
               * @example 12035
               */
              code?: number;
            };
          };
        };
      };
      401: components["responses"]["Unauthenticated"];
      402: components["responses"]["OutOfSeats"];
      403: components["responses"]["LicenseError"];
      404: components["responses"]["ResourceCouldNotBeFound"];
      500: components["responses"]["UnexpectedError"];
    };
    requestBody: {
      content: {
        "application/json": {
          /**
           * @description An API key to validate
           * @example secret-api-key
           */
          secret: string;
        };
      };
    };
  };
}

export interface external {}
